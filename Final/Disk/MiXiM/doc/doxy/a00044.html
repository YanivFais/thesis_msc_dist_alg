<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MiXiM: ConstInterpolateableIterator&lt; Key, V, Pair, Iterator, Interpolator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ConstInterpolateableIterator&lt; Key, V, Pair, Iterator, Interpolator &gt; Class Template Reference<br>
<small>
[<a class="el" href="a00314.html">mappingDetails - mostly internal mapping classes</a>]</small>
</h1><!-- doxytag: class="ConstInterpolateableIterator" -->Template for an interpolateable const iterator for any container which maps from a key to a value. This doesn't necessarily has to be a map, but also can be a sorted list of pairs.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00366.html">Interpolation.h</a>&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for ConstInterpolateableIterator&lt; Key, V, Pair, Iterator, Interpolator &gt;:</div>
<div class="dynsection">
<p><center><img src="a00847.png" border="0" usemap="#a00848" alt="Collaboration graph"></center>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="a00849.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00075.html">Interpolated</a>&lt; V &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#0bd90e4c1343616f900eca29d7de2ad2">interpolated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">typedef for the returned <a class="el" href="a00075.html" title="Represents an interpolated value of any type.">Interpolated</a> value of this class.  <a href="#0bd90e4c1343616f900eca29d7de2ad2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#d7a42a18b0244e30e360b0aeaa30b46d">ConstInterpolateableIterator</a> (Iterator <a class="el" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>, Iterator <a class="el" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>, const Interpolator &amp;intpl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the iterator with the passed Iterators as boundaries.  <a href="#d7a42a18b0244e30e360b0aeaa30b46d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#f7ccc6f48efc6d65e50185103decc593">operator==</a> (const <a class="el" href="a00044.html">ConstInterpolateableIterator</a> &amp;other)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#3ee2c46cae727908bc6460d1151e45bf">jumpTo</a> (const Key &amp;pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the iterator to the passed position. This position can be any value of the Key-type.  <a href="#3ee2c46cae727908bc6460d1151e45bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#17a318776fab3ddaba07be71dd7d503b">jumpToBegin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the iterator to the first element.  <a href="#17a318776fab3ddaba07be71dd7d503b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#996dfd3bb03b74bf863aade5ddb3c664">iterateTo</a> (const Key &amp;pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">forward iterates the iterator to the passed position. This position can be any value of the Key-type.  <a href="#996dfd3bb03b74bf863aade5ddb3c664"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#927effb5bd81dea6856406631177ef07">next</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates to the next entry in the underlying data structure.  <a href="#927effb5bd81dea6856406631177ef07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#29eeb644db0a86c6278d14f9c04d435a">getNextPosition</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#128edfa5b20b79e513377fbf334d1b16">inRange</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the current position of the iterator is between the position of the first and the last entry of the data structure.  <a href="#128edfa5b20b79e513377fbf334d1b16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#e47fa6975dfe70589405b6f6295c3a75">hasNext</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the a call of "next()" would increase to the position of an a valid entry of the data structure. This means if the current position is smaller than position of the last entry.  <a href="#e47fa6975dfe70589405b6f6295c3a75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00075.html">interpolated</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aa8804205f89382e08fb104275b1e23a">getValue</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the interpolated value at the current position of the Iterator.  <a href="#aa8804205f89382e08fb104275b1e23a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00075.html">interpolated</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#91134a17760f86c5fec23c14f44ad506">getNextValue</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#8834cdbbdc12733935aec116bd0ceddb">getPosition</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current position of the iterator.  <a href="#8834cdbbdc12733935aec116bd0ceddb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const Interpolator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#46727117126e5bdda724d533c72e67b9">interpolate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00107.html">PairLess</a>&lt; Pair, Key &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#fee623436b5ac96648b509273974ec72">comp</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt;<br>
 class ConstInterpolateableIterator&lt; Key, V, Pair, Iterator, Interpolator &gt;</h3>

Template for an interpolateable const iterator for any container which maps from a key to a value. This doesn't necessarily has to be a map, but also can be a sorted list of pairs. 
<p>
The <a class="el" href="a00044.html" title="Template for an interpolateable const iterator for any container which maps from...">ConstInterpolateableIterator</a> provides an iterator which as able to iterate in arbitrary steps over a iterateable number of pairs of "Key" and "Value". To determine the Value for a Key which does not exist in within the iterateable number of pairs it Interpolates between the nearby existing pairs. The actual Interpolation is determined by the passed Interpolator-template parameter.<p>
An example use would be to be able to iterate over a std::map&lt;double, double&gt; in arbitrary steps (even at positions for which no Key exist inside the map) and be able to return an interpolated Value.<p>
NOTE: The <a class="el" href="a00044.html" title="Template for an interpolateable const iterator for any container which maps from...">ConstInterpolateableIterator</a> will become invalid if the underlying data structure is changed!<p>
Template parameters: Pair - the type of the pair used as values in the container. Default is std::map&lt;Key, V&gt;::value_type (which is of type std::pair&lt;Key, V&gt;. The Pair type has to provide the two public members "first" and "second". Key - The type of the "first" member of the Pair type V - the type of the "second" member of the Pair type Iterator - the type of the iterator of the container (should be a const iterator). Default is std::map&lt;Key, V&gt;::const_iterator Interpolator - The Interpolation operator to use, this has to be a class which overwrites the ()-operator with the following parameters: <a class="el" href="a00075.html" title="Represents an interpolated value of any type.">Interpolated</a> operator()(const Iterator&amp; first, const Iterator&amp; last, const Key&amp; pos) <a class="el" href="a00075.html" title="Represents an interpolated value of any type.">Interpolated</a> operator()(const Iterator&amp; first, const Iterator&amp; last, const Key&amp; pos, Iterator upperBound) See the <a class="el" href="a00102.html" title="Given two iterators defining a range of key-value-pairs this class provides interpolation...">NextSmaller</a> template for an example of an Interpolator. Default is NextSmaller&lt;Key, V, Pair, Iterator&gt;.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Karl Wessel </dd></dl>

<p>Definition at line <a class="el" href="a00366.html#l00339">339</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="0bd90e4c1343616f900eca29d7de2ad2"></a><!-- doxytag: member="ConstInterpolateableIterator::interpolated" ref="0bd90e4c1343616f900eca29d7de2ad2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00075.html">Interpolated</a>&lt;V&gt; <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::<a class="el" href="a00075.html">interpolated</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
typedef for the returned <a class="el" href="a00075.html" title="Represents an interpolated value of any type.">Interpolated</a> value of this class. 
<p>

<p>Definition at line <a class="el" href="a00366.html#l00342">342</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d7a42a18b0244e30e360b0aeaa30b46d"></a><!-- doxytag: member="ConstInterpolateableIterator::ConstInterpolateableIterator" ref="d7a42a18b0244e30e360b0aeaa30b46d" args="(Iterator first, Iterator last, const Interpolator &amp;intpl)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::<a class="el" href="a00044.html">ConstInterpolateableIterator</a>           </td>
          <td>(</td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interpolator &amp;&nbsp;</td>
          <td class="paramname"> <em>intpl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the iterator with the passed Iterators as boundaries. 
<p>

<p>Definition at line <a class="el" href="a00366.html#l00358">358</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00358"></a>00358                                                                                         :
<a name="l00359"></a>00359     <a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>(<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>), <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>(<a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>), <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>(<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>), <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a>(), <a class="code" href="a00044.html#46727117126e5bdda724d533c72e67b9">interpolate</a>(intpl), <a class="code" href="a00044.html#fee623436b5ac96648b509273974ec72">comp</a>(){
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <a class="code" href="a00044.html#17a318776fab3ddaba07be71dd7d503b" title="Moves the iterator to the first element.">jumpToBegin</a>();
<a name="l00362"></a>00362   }

</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="29eeb644db0a86c6278d14f9c04d435a"></a><!-- doxytag: member="ConstInterpolateableIterator::getNextPosition" ref="29eeb644db0a86c6278d14f9c04d435a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Key <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::getNextPosition           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00429">429</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00429"></a>00429                        {
<a name="l00430"></a>00430     <span class="keywordflow">if</span>(<a class="code" href="a00044.html#e47fa6975dfe70589405b6f6295c3a75" title="Returns true if the a call of &amp;quot;next()&amp;quot; would increase to the position of...">hasNext</a>())
<a name="l00431"></a>00431       <span class="keywordflow">return</span> <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>-&gt;first;
<a name="l00432"></a>00432     <span class="keywordflow">else</span>
<a name="l00433"></a>00433       <span class="keywordflow">return</span> <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> + 1;
<a name="l00434"></a>00434   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="91134a17760f86c5fec23c14f44ad506"></a><!-- doxytag: member="ConstInterpolateableIterator::getNextValue" ref="91134a17760f86c5fec23c14f44ad506" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00075.html">interpolated</a> <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::getNextValue           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00469">469</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00469"></a>00469                                    {
<a name="l00470"></a>00470     <span class="keywordflow">if</span>(<a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a> == <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>)
<a name="l00471"></a>00471       <span class="keywordflow">return</span> <a class="code" href="a00044.html#46727117126e5bdda724d533c72e67b9">interpolate</a>(<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>, <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>, <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> + 1, <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>);
<a name="l00472"></a>00472     <span class="keywordflow">else</span>{
<a name="l00473"></a>00473       Iterator tmp = <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>;
<a name="l00474"></a>00474       <span class="keywordflow">return</span> <a class="code" href="a00044.html#46727117126e5bdda724d533c72e67b9">interpolate</a>(<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>, <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>, <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>-&gt;first, ++tmp);
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8834cdbbdc12733935aec116bd0ceddb"></a><!-- doxytag: member="ConstInterpolateableIterator::getPosition" ref="8834cdbbdc12733935aec116bd0ceddb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Key <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::getPosition           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current position of the iterator. 
<p>

<p>Definition at line <a class="el" href="a00366.html#l00481">481</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00481"></a>00481                          {
<a name="l00482"></a>00482     <span class="keywordflow">return</span> <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a>;
<a name="l00483"></a>00483   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="aa8804205f89382e08fb104275b1e23a"></a><!-- doxytag: member="ConstInterpolateableIterator::getValue" ref="aa8804205f89382e08fb104275b1e23a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00075.html">interpolated</a> <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::getValue           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the interpolated value at the current position of the Iterator. 
<p>
See definition of <a class="el" href="a00075.html" title="Represents an interpolated value of any type.">Interpolated</a> on details on the return type. 
<p>Definition at line <a class="el" href="a00366.html#l00464">464</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00464"></a>00464                                {
<a name="l00465"></a>00465 
<a name="l00466"></a>00466     <span class="keywordflow">return</span> <a class="code" href="a00044.html#46727117126e5bdda724d533c72e67b9">interpolate</a>(<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>, <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>, <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a>, <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>);
<a name="l00467"></a>00467   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e47fa6975dfe70589405b6f6295c3a75"></a><!-- doxytag: member="ConstInterpolateableIterator::hasNext" ref="e47fa6975dfe70589405b6f6295c3a75" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::hasNext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the a call of "next()" would increase to the position of an a valid entry of the data structure. This means if the current position is smaller than position of the last entry. 
<p>

<p>Definition at line <a class="el" href="a00366.html#l00454">454</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00429">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getNextPosition()</a>, and <a class="el" href="a00366.html#l00421">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::next()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00454"></a>00454                       {
<a name="l00455"></a>00455     <span class="keywordflow">return</span> <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a> != <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>;
<a name="l00456"></a>00456   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="128edfa5b20b79e513377fbf334d1b16"></a><!-- doxytag: member="ConstInterpolateableIterator::inRange" ref="128edfa5b20b79e513377fbf334d1b16" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::inRange           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the current position of the iterator is between the position of the first and the last entry of the data structure. 
<p>

<p>Definition at line <a class="el" href="a00366.html#l00440">440</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00440"></a>00440                       {
<a name="l00441"></a>00441     <span class="keywordflow">if</span>(<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a> == <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>)
<a name="l00442"></a>00442       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444     Iterator tail = <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446     <span class="keywordflow">return</span> !(<a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> &lt; <a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>-&gt;first) &amp;&amp; !((--tail)-&gt;first &lt; <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a>);
<a name="l00447"></a>00447   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="996dfd3bb03b74bf863aade5ddb3c664"></a><!-- doxytag: member="ConstInterpolateableIterator::iterateTo" ref="996dfd3bb03b74bf863aade5ddb3c664" args="(const Key &amp;pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::iterateTo           </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
forward iterates the iterator to the passed position. This position can be any value of the Key-type. 
<p>
This method assumes that the passed position is near the current position of the iterator. If this is the case this method will be faster than the jumpTo-method. 
<p>Definition at line <a class="el" href="a00366.html#l00403">403</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00403"></a>00403                                  {
<a name="l00404"></a>00404     <span class="keywordflow">if</span>(pos == <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a>)
<a name="l00405"></a>00405       <span class="keywordflow">return</span>;
<a name="l00406"></a>00406 
<a name="l00407"></a>00407     <span class="keywordflow">while</span>(<a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a> != <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a> &amp;&amp; !(pos &lt; right-&gt;<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>))
<a name="l00408"></a>00408       <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>++;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> = pos;
<a name="l00411"></a>00411   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3ee2c46cae727908bc6460d1151e45bf"></a><!-- doxytag: member="ConstInterpolateableIterator::jumpTo" ref="3ee2c46cae727908bc6460d1151e45bf" args="(const Key &amp;pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::jumpTo           </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator to the passed position. This position can be any value of the Key-type. 
<p>

<p>Definition at line <a class="el" href="a00366.html#l00372">372</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00599">InterpolateableMap&lt; double, Mapping *, Linear&lt; double, Mapping *, std::map&lt; double, Mapping * &gt;::value_type, std::map&lt; double, Mapping * &gt;::const_iterator &gt; &gt;::findIntpl()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00372"></a>00372                               {
<a name="l00373"></a>00373     <span class="keywordflow">if</span>(pos == <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a>)
<a name="l00374"></a>00374       <span class="keywordflow">return</span>;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376     <span class="keywordflow">if</span>(<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a> != <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>)
<a name="l00377"></a>00377       <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a> = std::upper_bound(<a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>, <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>, pos, <a class="code" href="a00044.html#fee623436b5ac96648b509273974ec72">comp</a>);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379     <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> = pos;
<a name="l00380"></a>00380   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="17a318776fab3ddaba07be71dd7d503b"></a><!-- doxytag: member="ConstInterpolateableIterator::jumpToBegin" ref="17a318776fab3ddaba07be71dd7d503b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::jumpToBegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the iterator to the first element. 
<p>

<p>Definition at line <a class="el" href="a00366.html#l00385">385</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00358">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::ConstInterpolateableIterator()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00385"></a>00385                      {
<a name="l00386"></a>00386     <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a> = <a class="code" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a>;
<a name="l00387"></a>00387     <span class="keywordflow">if</span>(<a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a> != <a class="code" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a>) {
<a name="l00388"></a>00388       <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> = <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>-&gt;first;
<a name="l00389"></a>00389       <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>++;
<a name="l00390"></a>00390     } <span class="keywordflow">else</span> {
<a name="l00391"></a>00391       <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> = Key();
<a name="l00392"></a>00392     }
<a name="l00393"></a>00393   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="927effb5bd81dea6856406631177ef07"></a><!-- doxytag: member="ConstInterpolateableIterator::next" ref="927effb5bd81dea6856406631177ef07" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::next           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterates to the next entry in the underlying data structure. 
<p>
If the current position is before the position of the first element of the data structure this method will iterate to the first entry. If the current position is after the position of the last element of the data structure this method will increase the current position with the ++ operator. 
<p>Definition at line <a class="el" href="a00366.html#l00421">421</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00421"></a>00421               {
<a name="l00422"></a>00422     <span class="keywordflow">if</span>(<a class="code" href="a00044.html#e47fa6975dfe70589405b6f6295c3a75" title="Returns true if the a call of &amp;quot;next()&amp;quot; would increase to the position of...">hasNext</a>()) {
<a name="l00423"></a>00423       <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> = <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>-&gt;first;
<a name="l00424"></a>00424       <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>++;
<a name="l00425"></a>00425     } <span class="keywordflow">else</span>
<a name="l00426"></a>00426       <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> += 1;
<a name="l00427"></a>00427   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f7ccc6f48efc6d65e50185103decc593"></a><!-- doxytag: member="ConstInterpolateableIterator::operator==" ref="f7ccc6f48efc6d65e50185103decc593" args="(const ConstInterpolateableIterator &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00364">364</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00364"></a>00364                                                              {
<a name="l00365"></a>00365     <span class="keywordflow">return</span> <a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> == other.<a class="code" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a> &amp;&amp; <a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a> == other.<a class="code" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a>;
<a name="l00366"></a>00366   }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="fee623436b5ac96648b509273974ec72"></a><!-- doxytag: member="ConstInterpolateableIterator::comp" ref="fee623436b5ac96648b509273974ec72" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00107.html">PairLess</a>&lt;Pair, Key&gt; <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::<a class="el" href="a00044.html#fee623436b5ac96648b509273974ec72">comp</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00352">352</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00372">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpTo()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5bade54a356cb196ef49c45873c25765"></a><!-- doxytag: member="ConstInterpolateableIterator::first" ref="5bade54a356cb196ef49c45873c25765" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::<a class="el" href="a00044.html#5bade54a356cb196ef49c45873c25765">first</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00344">344</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00469">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getNextValue()</a>, <a class="el" href="a00366.html#l00464">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getValue()</a>, <a class="el" href="a00366.html#l00440">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::inRange()</a>, <a class="el" href="a00366.html#l00403">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::iterateTo()</a>, <a class="el" href="a00366.html#l00372">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpTo()</a>, and <a class="el" href="a00366.html#l00385">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpToBegin()</a>.</p>

</div>
</div><p>
<a class="anchor" name="46727117126e5bdda724d533c72e67b9"></a><!-- doxytag: member="ConstInterpolateableIterator::interpolate" ref="46727117126e5bdda724d533c72e67b9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Interpolator&amp; <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::<a class="el" href="a00044.html#46727117126e5bdda724d533c72e67b9">interpolate</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00350">350</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00469">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getNextValue()</a>, and <a class="el" href="a00366.html#l00464">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getValue()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2627a7fb3b5eefaefadd1b7563a655ef"></a><!-- doxytag: member="ConstInterpolateableIterator::last" ref="2627a7fb3b5eefaefadd1b7563a655ef" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::<a class="el" href="a00044.html#2627a7fb3b5eefaefadd1b7563a655ef">last</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00345">345</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00469">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getNextValue()</a>, <a class="el" href="a00366.html#l00464">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getValue()</a>, <a class="el" href="a00366.html#l00454">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::hasNext()</a>, <a class="el" href="a00366.html#l00440">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::inRange()</a>, <a class="el" href="a00366.html#l00403">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::iterateTo()</a>, <a class="el" href="a00366.html#l00372">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpTo()</a>, and <a class="el" href="a00366.html#l00385">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpToBegin()</a>.</p>

</div>
</div><p>
<a class="anchor" name="37b17a78c6501554619277e34c32475c"></a><!-- doxytag: member="ConstInterpolateableIterator::position" ref="37b17a78c6501554619277e34c32475c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Key <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::<a class="el" href="a00044.html#37b17a78c6501554619277e34c32475c">position</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00349">349</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00429">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getNextPosition()</a>, <a class="el" href="a00366.html#l00469">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getNextValue()</a>, <a class="el" href="a00366.html#l00481">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getPosition()</a>, <a class="el" href="a00366.html#l00464">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getValue()</a>, <a class="el" href="a00366.html#l00440">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::inRange()</a>, <a class="el" href="a00366.html#l00403">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::iterateTo()</a>, <a class="el" href="a00366.html#l00372">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpTo()</a>, <a class="el" href="a00366.html#l00385">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpToBegin()</a>, <a class="el" href="a00366.html#l00421">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::next()</a>, and <a class="el" href="a00366.html#l00364">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::operator==()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0f61dfafb18613acccd2e103c1445a98"></a><!-- doxytag: member="ConstInterpolateableIterator::right" ref="0f61dfafb18613acccd2e103c1445a98" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class V, class Pair = const typename std::map&lt;Key, V&gt;::value_type, class Iterator = const typename std::map&lt;Key, V&gt;::const_iterator, class Interpolator = NextSmaller&lt;Key, V, Pair, Iterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator <a class="el" href="a00044.html">ConstInterpolateableIterator</a>&lt; Key, V, Pair, Iterator, Interpolator &gt;::<a class="el" href="a00044.html#0f61dfafb18613acccd2e103c1445a98">right</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="a00366.html#l00347">347</a> of file <a class="el" href="a00366.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00366.html#l00429">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getNextPosition()</a>, <a class="el" href="a00366.html#l00469">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getNextValue()</a>, <a class="el" href="a00366.html#l00464">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::getValue()</a>, <a class="el" href="a00366.html#l00454">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::hasNext()</a>, <a class="el" href="a00366.html#l00403">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::iterateTo()</a>, <a class="el" href="a00366.html#l00372">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpTo()</a>, <a class="el" href="a00366.html#l00385">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::jumpToBegin()</a>, <a class="el" href="a00366.html#l00421">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::next()</a>, and <a class="el" href="a00366.html#l00364">ConstInterpolateableIterator&lt; Key, V, Container::value_type, Container::iterator, Interpolator &gt;::operator==()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>base/phyLayer/<a class="el" href="a00366.html">Interpolation.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Sep 28 15:57:01 2009 for MiXiM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
