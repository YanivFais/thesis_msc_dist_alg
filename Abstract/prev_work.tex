\def\conff{1}
%\def\conff{0}

\ifnum\conff=0
\documentclass[12pt]{article}
\fi

\ifnum\conff=1
\documentclass{sig-alternate-10pt}
\fi

\usepackage{times}
\usepackage{url}
\usepackage{comment}
\usepackage[english]{babel}
\usepackage{array}

%\usepackage{float}
%\floatstyle{ruled}
\usepackage{algorithm}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{graphicx}
\graphicspath{{./Figs/}}

\usepackage{paralist}

\ifnum\conff=0
\usepackage[active]{srcltx}
\usepackage[a4paper]{geometry}
\geometry{hmargin=1in,top=1in}
\usepackage{setspace}%\singlespacing

\usepackage{amsthm}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{theoremnonum}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{coro}[theorem]{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{observation}{observation}
\newtheorem{definition}{Definition}


\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \newcommand{\qed}{$\blacksquare$}
% \newenvironment{proof}{\noindent {\bf Proof:} }{\hfill \qed}
\newenvironment{proof sketch}[1]{\noindent {\emph{Proof sketch of #1:}}}{\hfill \qed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\newenvironment{proof}{\noindent {\bfseries Proof.} }
%  {\mbox{}\nolinebreak \hfill \qed}
\newcommand{\eps}{\varepsilon}

\newcommand{\flow}{\text{\emph{flow}}}
\newcommand{\poly}{\text{\emph{poly}}}
\newcommand{\source}{\text{\emph{source}}}
\newcommand{\target}{\text{\emph{target}}}
\newcommand{\demand}{\text{\emph{demand}}}
\newcommand{\reject}{\text{\emph{reject}}}
%\newcommand{\load}{\text{\emph{load}}}
%\newcommand{\far}{R^{\text{\emph{Far}}}}
%\newcommand{\near}{R^{\text{\emph{Near}}}}
\newcommand{\opt}{\text{\textsc{opt}}}
\newcommand{\iopt}{I^*}
%\newcommand{\alg}{\textit{Alg}}
%\newcommand{\algf}{\textit{Alg}_{\text{\textit{far}}}}
%\newcommand{\algn}{\textit{Alg}_{\text{\textit{near}}}}
\newcommand{\eqdf}{\triangleq}

\newcommand{\Alg}{\text{\sc{alg-name}}}
\newcommand{\SINR}{\text{\sc{sinr}}}
\newcommand{\SNR}{\text{\sc{snr}}}
\newcommand{\PER}{\text{\sc{per}}}
\newcommand{\pps}{\text{\emph{pps}}}
\newcommand{\hops}{\text{\emph{hops}}}
\newcommand{\mf}{\text{\emph{mf}}}
\newcommand{\MCS}{\text{\sc{mcs}}}
\newcommand{\Ein}{E_{\text{\emph{in}}}}
\newcommand{\Eout}{E_{\text{\emph{out}}}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\Imodel}{$\cal{I}$}

\newcommand{\algA}{\textsc{MF-I-S}}
\newcommand{\algB}{\textsc{ShortP}}
\newcommand{\algC}{\textsc{MF-I}}
\newcommand{\algD}{\textsc{MF}}
\newcommand{\algE}{\textsc{MF-S}}

\newcommand{\algS}{\algB}

\begin{document}
%\begin{titlepage}
\title{Real-Time Video Streaming in Multi-hop Wireless Static Ad Hoc Networks}

\ifnum\conff=0
\author{%
Guy Even\thanks{School of Electrical Engineering,
Tel-Aviv Univ., Tel-Aviv 69978, Israel.
\protect\url{{guy,medinamo,moni,sasha}@eng.tau.ac.il}}
\and
Yaniv Fais$^*$
\and
Moti Medina$^*$
%
\and Shimon (Moni) Shahar$^*$
\and Alexander Zadorojniy$^*$ }
\fi
\date{}

\maketitle


%%% ----------------------------------------------------------------------

\begin{abstract}
  In this paper we deal with the problem of streaming multiple video
  streams between pairs of nodes in a multi-hop wireless ad hoc
  network.  The nodes are positioned on a plane, know their locations,
  and are synchronized (via GPS). We consider a 802.11g WiFi network
  in which NICs can hop between non-overlapping frequency channels in
  a synchronous fashion. Our goal is to maximize the minimum
  throughput over all the video streams. We designed a centralized
  algorithm that computes a channel/time-slot table.  Each entry in
  the table specifies the active links.

  Our algorithm constructs a communication graph based on distances.
  For each link in the communication graph, a set of interfering links
  is defined based on distances and the SNR of the link.  A
  multicommodity flow with interference constraints is solved by
  linear programming. The flow is then rounded to obtain the
  channel/time-slot table. After the table is broadcast, each node
  receives and transmits according to the table. In addition, we developed a localized
  flow-control mechanism to stabilize the queue lengths.

  We simulated our algorithm using OMNET++/MixiM (i.e., physical SINR
  interference model) to test whether the computed throughput is
  achieved. Our results show that we are able to route 95\% of the
  computed throughput.
\end{abstract}


\paragraph{
Keywords:}


%\end{titlepage}
\section{Introduction}

\paragraph{Special characteristics of real-time video streaming}
Streaming of real-time video in a multi-hop ad hoc network is a
challenging task.  We briefly overview these features and
challenges.
\begin{inparaenum}[(1)]
%  \item Video coding (e.g., H.264/MPEG) creates a bursty stream since
%    I-frames are much longer than the other frames. One could smoothen
%    the stream at the cost of incurring a extra delay of a second
%    (i.e., the time between I-frames).
\item End-to-end delay in streaming of real-time video should be as
  small as possible.  We assume that a delay of $1$-$2$ seconds is
  tolerable if the video has to travel across $10$ hops.  One
  implication of this constraint is that end-to-end acknowledgments and TCP are
  not an option.
\item Unless erasure codes are employed, loosing even a small fraction
  of the packets incurs an intolerable degradation in the video
  quality. In wireless networks, each link can have a \PER\ of
  $1\%$-$5\%$. Thus, after $10$ hops, one is left with intolerable
  erasures.  On the other had, erasure codes incur an extra end-to-end
  delay since they need to accumulate data for a block before encoding
  can take place. This means that relying on WiFi acknowledgments and
  retransmit capabilities can be useful to avoid packet drops if the \PER\
  is small.
\item A useful feature in video coding is the ability to adjust the
  compressed bit-rate. This means that the video encoder can be
  continuously controlled to generate a video stream of a requested
  bit rate. We rely on this feature in our flow control algorithm.
  This feature separates video streaming from other applications such
  as FTP.
\item The necessity of cross layer designs have been recognized for
  satisfying the special characteristics of real-time video streaming
  over wireless
  networks~\cite{shan2005cross,setton2005cross,khan2006application}.
  We continue this line of work.
\end{inparaenum}
\paragraph{Previous Work}

The WiFi technology builds on the 802.11 protocol, where in this paper we used the 802.11g standard. The exact details of the communication, such as RTS/CTS messages, and hold off time are described in details in ~\cite{gast2005802}. The standard has 8 Modulation Coding Schemes (MCS) which defines the data rate, coding and modulation. The MCS are ordered from a rate of 6Mbps for MCS(1) to rate of 54Mbps for MCS(8). In case where the signal to noise (SNR) is high, one may use high MCS for data transmission and obtain high throughput. Adapting the MCS is one of the ways to decrease the error rate in case of change in the SNR ~\cite{kamerman1997wavelan,holland2001rate}.

The multi-hop routing problem for Ad Hoc networks was investigated thoroughly. One of the commonly used heuristic for routing is based on finding paths with maximum bottleneck, namely, paths for which the edge with the lowest capacity is maximum ~\cite{draves2004routing}. In this paper the goal function is a combination of maximizing the bottleneck and the total throughput. We used this algorithm in our benchmarks. A different approach for the routing problem is based on solving a linear program. In ~\cite{jain2005impact} Jain et. al. used a graph to approximate the interference model, where two links either interfere each other or not. This is an approximation to the physical interference model, where using few links simultaneously may sum up to interfere a link. Using this conflict graph they adds interference constraints to a flow linear program. Next, he approximates its solution (the exact solution is proved to be NP-Hard) and obtain a routing that can be scheduled. In this paper they demonstrate their results on simple scenarios such as grid. Following Jain, in ~\cite{alicherry2005joint11} a similar linear program is given for multi-radio. They also tested their results on a grid and on random scenarios. In ~\cite{buragohain2007improved} the authors used a different linear program, whose conflict constraints are given for vertices, so as to obtain a better approximation ratio. Finally, in 2009 Wan showed that there is an error in their algorithm and presented a new linear program that corrects the problem. He proved that: (i) there is a $23$-approximation algorithm based on the linear program, and (ii) there is a polynomial time scheme for the problem, however its implementation is very complicated ~\cite{wan2009multiflows}. The linear program Wan presented is larger then Jain's linear program, and even for a modest size network (few tens of vertices) its implementation is impractical. 



\paragraph{Our Contributions}
\begin{enumerate}
\item We perform a simulation of real-time video streaming in a
  standard 802.11g setting (Sec.~\ref{sec:exp}).  In this setting, all WiFi frames are
  transmitted (i.e., RTS,CTS, packet, ACK), and interferences between
  frames are analyzed using the SINR and the MCS.
\item We introduce new interference constraints for the linear program
  formulation (Sec.~\ref{sec:LP}).  These constraints define the interference set of a
  link as a function of the signal-to-noise ratio of the link and the
  \MCS of the link.  As the link is closer to the \SINR-threshold, the
  interference set grows, so that \SINR\ is not in the ``waterfall''
  region of the \PER\ function.
\item We formulate the problem of minimizing end-to-end delay due to a
  schedule that supports a a given multi-flow. We developed and
  implemented a scheduler algorithm that address this problem of
  reducing end-to-end delays while supporting a similar throughput.
  (Sec~\ref{sec:sched}).
\item We developed and implemented a flow control algorithm that
  stabilizes the queue lengths and controls the data-rate along the
  links.  This flow control algorithm is executed locally by the
  nodes.
\item We combine the various aspects of video streaming to analyze the
  performance that is crucial for real-time video streaming.  Namely,
  we measured the throughput, end-to-end delay, fraction of dropped
  packets, and the stability of these parameters.
\end{enumerate}

\paragraph{Techniques}
The algorithm computes two tables: a multi-flow table $\mf$ and a
time-slotted frequency table $A$ that governs communication in the
network. Each entry $A[j,t]$ of the table is indexed by a frequency
channel $j$ and a time slot $t$ pair.  The set of links that appear in
$A[j,t]$ are supposed to deliver packets in time slot $t$ using the
frequency channel $j$.


 The algorithm computes a
\paragraph{Organization}

\section{Problem Definition}\label{sec:problem}
\paragraph{Setting}
We consider a WiFi 802.11g mesh network with $3$ non-interfering radio
channels with the assumptions:
\begin{inparaenum}[(i)]
\item Single radio: each node has a single wireless network interface
  controller (WNIC).
\item Each node is equipped with a GPS so that it knows
  its location and the nodes are synchronized.
\item The WNICs support quick synchronized hops between frequency
  channels.
\item Isotropic antennas.
\item We also assume that the nodes have
already joined the network and that there is at least one node (i.e.,
center node) that holds full information about the network (e.g.,
nodes and locations).  Accumulating this information can be done in a
distributed low-bandwidth fashion by building a spanning
tree~\cite{awerbuch1987optimal}.
\end{inparaenum}




\paragraph{Problem Definition}
The input to the algorithms consists of:
\begin{enumerate}
\item A set $V$ of $n$ nodes in the plane. A transceiver is located in
  each node.
\item A set of $k$ video stream requests $\{r_i\}_{i=1}^k$. Each
  stream request is a triple $r_i\eqdf (a_i,b_i,d^*_i)$, where $a_i$ is
  the source (e.g., camera) of the stream, $b_i$ is the destination,
  and $d^*_i$ is the required data-rate.
\end{enumerate}
Ideally, we would like to satisfy all the requests, namely, for each
video stream $r_i$, route packets using multi-hops from $a_i$ to $b_i$.
We assume that there is there is a path in the network between each
source-destination pair.

Let $d_i$ denote the data-rate achieved for the $i$th stream.  The
service ratio $\rho_i$ of the $i$th demand is defined by $\rho_i \eqdf
d_i/d^*_i$.  Our goal is to maximize the minimum service ratio,
namely, $\max \min_i \rho_i$.

Additional performance measures are:
\begin{inparaenum}[(i)]
\item End-to-end delay - this is the time it takes a packet to reach
  its destination. We are interested in reducing the maximum delay
  (among the packets that are delivered) since the video is real-time.
  In addition, the maximum delay determines the size of the jitter
  buffer in the receiving side.
\item Number of dropped packets. Queue management may drop packets
  that never reach their destination.
\item Queue lengths in intermediate nodes tell us how much memory
  should be allocated and also give an indication of the delay per hop.
\end{inparaenum}

\section{Preliminaries}
\label{sec:prelim}

\subsection{Interference Models}

\paragraph{Bidirectional interference}
The delivery of a message in the WiFi MAC requires transmission of
frames by both sides (e.g., RTS and packet are transmitted by the
sender, CTS and ACK are transmitted by the receiver). Hence,
interferences can be caused also by frames transmitted by a the
receiving side.

\noindent
We outline the three interference models below.
\paragraph{The SINR model}
The SINR model, also called the physical
interference model, defines successful communication as follows.  Let
$d_{u,v}$ denote the distance between nodes $u$ and $v$.  Suppose a subset
$S_t\subseteq V$ of the nodes are transmitting simultaneously in the
same frequency channel as $u$.  The signal-to-interference-plus-noise
ratio (SINR) for the reception by $v\in V\setminus S_t$ of the signal
transmitted by $u\in S_t$ in the presence of the transmitters $S_t$ is
defined by
\[
\SINR(u,v,S_t) \eqdf \frac{P/d_{u,v}^{\alpha}}{N+\sum_{x\in
    S_t\setminus{u}} P/d_{x,v}^{\alpha}}.
\]
Each transmitter can use one of several modulation coding schemes (\MCS).
The message transmitted by $u$ in an \MCS\ $m$ is successfully received by
$v$ if $\SINR(u,v,S_t)\geq \beta_m$, where $\beta_m$ is the minimum
SINR-threshold for the \MCS\ $m$.

\paragraph{Protocol model}
The protocol model, also called the graph model, is specified by two
radii:
\begin{inparaenum}[(i)]
\item A communication distance $r$.
\item An interference distance $R$.
\end{inparaenum}
The rule for successful communication between two nodes $u$ and $v$ is
that $v$ receives the message from $u$ if $d_{u,v}<r$ and every node
$x$ that transmits at the same time satisfies $d_{xv}> R$.  In this
model, a communication graph is defined over the nodes.  Two nodes are
linked by an edge if their distance is less than the communication
distance $r$.

Since the WiFi MAC requires transmission by both sides, an
\emph{interference} is defined between two links $(u,v)$ and $(u',v')$
if $\min\{d_{u,u'},d_{u,v'}, d_{v,u'}, d_{v,v'}\} < R$.  We say that a
subset $L$ of links is \emph{non-interfering} if no two links in $L$
interfere.  In the protocol model, a \emph{schedule} is a sequence
$\{L_i\}_i$ of subsets of non-interfering links.


\paragraph{The new model}
The new model is an intermediate model between the SINR model and the
protocol model. The idea is that, as the \SNR\ of a link grows, the
link can tolerate more interference. Hence, the interference distance
is not fixed.

Consider a pair $(u,v)$ of nodes and an \MCS\ $m$.
The triple $(u,v,m)$ is a \emph{link} in the new model if
$\SINR(u,v,\emptyset) \geq \beta_m$.

Since both sides of a link transmit and receive, the interference set
of a link must take into account interferences caused by other
transmissions both in the receiver and the sender. However, the frames
sent by the receiving side are in \MCS $0$, therefore, reception of
these frames depends on the $\SINR$-threshold $\beta_0$.

The interference set $V_{u,v,m}$ of the link $e=(u,v,m)$ is defined by
  \begin{align*}
    V_{u,v,m} \eqdf \left\{ x \in V \setminus\{u\}\right. &\left | \SINR(u,v,\{x\}) \geq \mu  \cdot \beta_i \text{ or } \right. \\
    & \left.\SINR(v,u,\{x\}) \geq \mu \cdot \beta_0\right\}.
\end{align*}
The motivation for this definition is that transmissions of nodes in $V_{u,v,m}$ interfere with
the reception of $v$ by $u$ or vice versa.
The choice of $\mu=1.585$ gives us a margin of $2$dB above the
\SINR-threshold.  This margin keeps the $\SINR$ above the threshold
due to interferences caused by transmitters not in $S_{u,v,m}$.

We also define the interfering set of edges with respect to the link $e=(u,v,m)$.
\begin{align*}
  I_{u,v,m} \eqdf \{ e'=(u',v',m') \mid &\{u',v'\} \cap (V_{u,v,m} \cup V_{v,u,m})
\\
& \neq \emptyset\} \setminus \{(u,v,m)\}.
\end{align*}
Recall that sending a packet in the WiFi protocol requires
transmission of frames both by the sending side and the receiving
side.  This explains why the interference set $I_{u,v,m}$ contains a
link $e'$ if either endpoint of $e'$ interferes with reception at the
endpoints $u$ or $v$.

\begin{comment}
  \begin{align*}
    S_{u,v,m} &\eqdf \left\{ x \in V \left | \frac{1}{6}\cdot
        \frac{P}{d_{x,v}^{\alpha}} > \left( \frac{P}{\beta\cdot
            d_{u,v}^{\alpha}} - N \right) \right.  \right\}
  \end{align*}
The justification for the definition of the interference set is summarized in the following claim.
\begin{claim}
Suppose $S_t$ is ``feasible''.
  If $S_t \cap S_{u,v,m}=\emptyset$ then
$\SINR(u,v,S_t) \geq \SINR (u,v,\emptyset) \cdot \gamma.$
\end{claim}
\end{comment}


\section{Algorithm}\label{sec:outline}
\subsection{Networks Governed by Time-Slotted Frequency Tables}
Two tables govern the communication in the network.  The first table
$A$ is a time-slotted frequency table. The dimensions of $A$ are
$F\times T$ table, where $F$ denotes the number of frequency channels
and $T$ denotes the number of time slots.  There is one row for each
frequency channel and one column for each time slot. (In our
implementation we used $F=3$ and $T=200$).  The second table is a
mult-flow table $\mf$. The dimensions of $\mf$ are $|E|\times [1..k]$.
The entry $\mf(e,s)$ specifies the number of packets-per-period that
should be delivered along link $e$ for stream $s$.

Each table entry $A[j,t]$ is a subset of links,
i.e., $A[j,t]\subseteq E$.  The table governs communication in the
sense that, in slot $t$, the links in $A[j,t]$ try to deliver packets
using frequency channel $j$.

We use $A[\cdot,t']$ to denote the set of links $\cup_{j\in F}
A[j,t']$.  Since we assume that each node is equipped is a single
radio, it follows that two links that share an endpoint cannot be
active in the same time slot.  Hence, for every node $v$, $E(v) \cap
A[\cdot ,t']$ may contain at most one link.

Algorithm \Alg\ computes a time-slotted frequency table that supports
a multi-flow (see Sec.~\ref{sec:output}). A time-slotted frequency
tables schedules active links as listed in Algorithm~\ref{alg:tx-rx}.
Each node $v$ executes Algorithm TX-RX$(v)$ locally.  Since $E(v) \cap
A[\cdot ,t']$ may contain at most one link, a node $v$ is either a
receiver, a sender, or inactive in each time slot.  We elaborate below how
a queue $Q(v,s)$ with the highest priority for transmission along link
$e$ in line~\ref{line:priority} in the Transmit procedure is defined.

Upon invocation of Transmit$(e,j)$, where $e=(v,u,m)$, the node $v$
needs to decide which packet to transmit. The node $v$ uses the
multi-flow table $\mf$ to determine the set $S_e$ of streams that are
routed along $e$.  Since delay is a major issue, it is reasonble to
use an EDD-like policy, i.e., pick the oldest packet in the queues
$Q(v,s)$, for $s\in S_e$.  However, such a policy ignores the
remaining number of hops a packet needs to traverse. We prefer the
approach of assigning a priority that equals the ratio of the number
of packets of stream $s$ transmiitted along $e$ in the last period
divided by the required number. The lower this ratio, the higher
priority of the stream. This approach also combines well with the flow
control algorithm described in Sec.~\ref{sec:flow control}.


\begin{algorithm}
  \caption{TX-RX$(v)$ - a local transmit-receive algorithm for node
    $v$ as specified by a time-slotted frequency table $A$.}
\label{alg:tx-rx}
For time slot $t=0$ to $\infty$ do
  \begin{enumerate}%1
  \item if $\Ein(v)\cap A[\cdot,t \pmod T]\neq \emptyset$ then
    \{reception mode\}
    \begin{enumerate}%2
    \item Let $e\in \Ein(v)\cap A[\cdot,t\pmod T]$, where $e(u,v,m)\in
      A[j,t]$.
    \item While slot $t$ is not over call Receive$(e,j)$.
    \end{enumerate}%2
  \item if $\Eout(v)\cap A[\cdot,t \pmod T]\neq \emptyset$ then
    \{transmission mode\}
    \begin{enumerate}%2
    \item Let $e\in \Eout(v)\cap A[\cdot,t \pmod T]$, where
      $e(v,u,m)\in A[j,t]$.
    \item While slot $t$ is not over call Transmit$(e,j)$.
    \end{enumerate}%2
  \end{enumerate}%1
Receive$(e,j)$ - where link $e=(u,v,m)$ and $j$ is a frequency channel.
\begin{enumerate}
\item Set tuner to reception in frequency channel $j$.
\item Upon reception of a packet $p$ from stream $s$, insert $p$ to $Q(v,s)$.
\end{enumerate}

Transmit$(e,j)$-  where link $e=(v,u,m)$ and $j$ is a frequency channel.
\begin{enumerate}
\item Set tuner to transmission in frequency channel $j$.
\item\label{line:priority} Pick a queue $Q(v,s)$ with a highest priority for transmission along $e$.
\item $p \gets DEQUEUE(Q(v,s))$.
\item Transmit $p$ along $e$.
\end{enumerate}
\end{algorithm}

\subsection{Algorithm Specification}
\paragraph{Input}
The input to Algorithm \Alg\ consists of the following:
\begin{enumerate}
\item A set $V\subseteq \RR^2$  of nodes in the plane.
\item A set of $k$ video stream requests $\{r_i\}_{i=1}^k$. Each
  request $r_i$ is a triple $r_i\eqdf (a_i,b_i,d^*_i)$, where $a_i$ is
  the source (e.g., camera) of the stream, $b_i$ is the destination,
  and $d^*_i$ is the required data-rate.
\end{enumerate}
\paragraph{Output}
\label{sec:output}
The output of Algorithm \Alg\ consists of two parts:
\begin{inparaenum}[(i)]
\item a time-slotted frequency table $A$, and
\item a multi-flow $\mf(e,s)$, for every link $e$ and stream $1\leq
  s\leq k$.
\end{inparaenum}
We note that the units of flow are packets-per-period, where the
period is the duration of a time slot times the number $T$ of
time-slots in a period.

The multi-flow $\mf(e,s)$ determines the routing and the throughout of
each stream. The role of the frequency/time-slot table $A$ is to
specify a periodic schedule that determines which links are active in
which time slots.

Although we use fixed length packets (e.g., 2KB), the
\MCS\ determines the amount of time required for completing the
delivery of a packet.  This means, that within one time slot, multiple
packets may be delivered along a single link.  Let $\pps(m)$ denote
the number of packets-per-slot that can be delivered in $\MCS(m)$.
Then, node $u$ can transmit at most $\pps(m)$ packets to node $v$
along link $e=(u,v,m)$ in one time-slot.

\medskip \noindent
The table $A$ should satisfy the following properties:
\begin{enumerate}
\item Every entry $A[j,t]$ in the table is a set of non-interfering
  links (in an interference model \Imodel). Thus the links in $A[j,t]$
  may be active simultaneously.
\item The data-rates $\mf(e,s)$ are supported by the table. Namely,
  \begin{align*}
    \sum_{s=1}^k \mf(e,s) \leq |\{A[j,t] \mid e\in A[j,t]\}|\cdot \pps(m),
  \end{align*}
\end{enumerate}

\subsection{Algorithm Description}
The algorithm consists of two parts: (i)~computation of a
multi-commodity flow with conflict constraints, and (ii)~scheduling of
the multi-commodity flow in a time-slotted frequency table.
We elaborate on each of these parts.

\paragraph{Multi-commodity flow with conflict constraints}
We formulate the problem of routing and scheduling the video streams
by a linear program (LP).  For each requested stream $r_i$, we define
the supply ratio $\rho_i$ to be the ratio between the flow allocated
to the $i$'th stream and the demand $d^*_i$ of the stream.  The
objective of the LP is to maximize $\min_i \rho_i$.  A secondary
objective is to maximize the total throughput.
\begin{figure*}
  \begin{align}
    \max ~~~\rho + \lambda \cdot\sum_{i=1}^k d^*_i \cdot \rho_i~~~~~~&\text{subject to}&\\
    f^j_i(e) &\geq 0&\forall i\in [1..k], \forall j\in [1..3], \forall e\in E \label{eq:pos}\\
    \sum_{j=1}^3 f_i^j(e) &=f_i(e)& \forall e\in E\label{eq:freq1}\\
    \sum_{i=1}^k f_i^j(e) &=f^j(e)& \forall e\in E\label{eq:freq2}\\
    \sum_{e \in \Eout (v)} f_i(e) - \sum_{e \in \Ein (v)} f_i(e) &=0 &\forall i\in [1..k],\forall v\in V\setminus \{a_i,b_i\}\label{eq:conservation}\\
    \sum_{i=1}^k f_i(e) &\leq c(e) &\forall e\in E \label{eq:cap}\\
    \sum_{e \in \Eout (v)} f_i(a_i) - \sum_{e \in \Ein (v)} f_i(a_i)&=d^*_i \cdot \rho_i &\forall i\in [1..k]\label{eq:rho_i}\\
    \rho &\leq \rho_i&\forall i\in 1..k]\label{eq:rho}\\
    \frac{f^j(e)}{c(e)} + \sum_{j'< j} \sum_{e'\in E(u)\cup E(v)}
    \frac{f^{j'}(e')}{c(e')} + \sum_{e' \in I_{e}}
    \frac{f^j(e')}{c(e')} & \leq 1 & \forall e=(u,v,m)\in E,\forall
    j\in[1..3] \label{eq:conf}
  \end{align}
\end{figure*}
The main variables of the LP are the flow variables $f_i^j(e)$ which
signifies the amount of flow along link $e$ in frequency channel $j$
for stream $i$.  In Eq.~\ref{eq:pos} we require that the flows are
nonnegative.  In Eq.~\ref{eq:freq1} we define $f_i(e)$ to be the
combined flow along $e$ for stream $i$ over all frequency channels.  In
Eq.~\ref{eq:freq2} we define $f^j(e)$ to be the combined flow along
$e$ in frequency channel $j$ over all $k$ streams.
Eq.~\ref{eq:conservation} is simply a flow conservation constraint for
stream $i$ in every intermediate node.  Eq.~\ref{eq:cap} is simply a
capacity constraint for every link.  In Eq~\ref{eq:rho_i}, the supply
ratio $\rho_i$ is defined to be the fraction of the demand for stream $i$
that is supplied.  In Eq.~\ref{eq:rho}, $\rho$ is defined to equal the
minimum supply ratio, i.e., $\rho=\min_i \rho_i$.  Finally, in
Eq.~\ref{eq:conf} the interference constraints are defined; we
elaborate on them below.

The objective is to maximize the minimum supply ratio $\rho$.  As a
secondary objective, we maximize the sum of flows.
Therefore, the constant $\lambda$ in the objective function is small
(e.g., $\lambda=1/20)$.

The left-hand-side of the interference constraint consists of three
addends. The first addend $f^j(e)/c(e)$ is the fraction of the time
that the link $e$ is active in transmission in frequency $j$. The
second addend is the fraction of time that the endpoints of $e$ are
active in transmissions in frequencies less than $j$.  Finally, the
third addend is the fraction of time in which links in the
interference set $I_e$ are active in transmissions in frequency $j$.
Recall that each node has a single radio.  This implies that the
fractions in the last two addends correspond to transmissions that may
not take place simultaneously with transmissions in the $j$th
frequency channel of link $e$.

We point out that the capacity constraints in Eq.~\ref{eq:cap} are
redundant since they are implied by the interference constraints in
Eq.~\ref{eq:conf}.

In our experiments, we noticed that the LP-solver found a solution
with flow cycles. We removed these cycles before applying the
scheduling step.  Interestingly, the issue of flow cycles was not
mentioned in previous
works~\cite{alicherry2005joint11,buragohain2007improved}


\paragraph{Scheduling of the multi-commodity flow in a time-slotted
  frequency table}
In the scheduling step we are given the multi-flows
$\{f^j_i(e)\}_{e\in E}$.  The task is to allocate entries in a
time-slotted frequency table $A$ for these flows.

We first determine how many time-slots should be allocated for
$f^j(e)$, for each link $e$ and each frequency channel $j$.  Recall
that a unit of flow is one packet-per-period.  Recall also that $\pps(m)$
denotes the number of packets-per-slot that can be delivered in
$\MCS(m)$.  This means that the number of time slots in which
$e=(u,v,m)$ should be allocated in frequency channel $j$ must be at
least
\begin{align*}
  |\{ t\in[1..T] :e\in A[j,t]\}| \cdot \pps(m) &\geq f^j(e)
\end{align*}
Hence,
\begin{align}\label{eq:req}
  |\{ t\in[1..T] :e\in A[j,t]\}| \geq \left\lceil \frac{f^j(e)}{\pps(m)} \right\rceil.
  \end{align}
\paragraph{The greedy scheduler}
  The simplest way to assign flows to the table $A$ is by applying a
  greedy algorithm.  The greedy algorithm scans the links and
  frequency channels, one by one, and assigns $\ell(e,j)$ slots to
  each link $e$ and frequency channel $j$.  Based
  on~\cite{alicherry2005joint11,kumar2004end,buragohain2007improved},
  the interference constraints in Eq.~\ref{eq:conf} imply that the
  greedy algorithm succeeds in this assignment provided that
\begin{align}\label{eq:guar}
 \ell(e,j) = \left\lfloor \frac{f^j(e)}{\pps(m)} \right\rfloor.
  \end{align}
  The issue of dealing with this rounding problem (i.e., the
  difference between the round-down and the round-up) is discussed
  in~\cite{wan2009multiflows}, where it is pointed out that routing
  all the flow requires a super exponential period $T$. Such a period
  is obviously not practical; the computation of the table takes too
  long, the table is too long to be broadcast to all nodes, and
  the schedule will incur huge delays.

  We show that the rounding problem is not an important issue both
  theoretically and in practice.  Since each flow $f_i$ can be
  decomposed into at most $|E|$ flow paths, it follows that the values
  of $\{f^j_i(e)\}_{e\in E, j\in F}$ can be ``rounded'' so that at
  most $|E|\cdot \max_i \{\MCS(i)\}$ packets are lost.  Note that this
  lost flow is bounded by a constant. By increasing the period $T$,
  the amount of flow tends to infinity, and hence, the lost flow is
  negligible. In our experiments~\ref{sec:exp}, we used a period of
  $T=200$ time slots, with a duration of $5ms$ per slot. The greedy
  scheduler was able to schedule almost all the flow in all the
  instances we considered.  The multi-flow table is set so that
  $\mf(e,s)$ equals the amount of flow from $f_s(e)$ that the
  scheduler successfully assigned.

 The greedy scheduler incurred a delay roughly of
  one period per hop. The reason is that it schedules all the
  receptions to a node before the transmissions from the node. To
  avoid this delay, we designed a new scheduler, described below.

\paragraph{The path-peeling scheduler}
The path peeling scheduler tries to reduce the time that an incoming
packet waits till it is forwarded to the next node. This is achieved
as follows.
\begin{enumerate}
\item Decomposes each flow $f_i$ into flow paths such that the flow
  along each path equals the bottleneck, i.e., the minimum $\pps(m)$ along the path.  Let
  $\{f_i(p)\}_{p\in {\cal{P}}(i)}$ denote this decomposition.
\item While not all the flow is scheduled,
  \begin{enumerate}
  \item \label{item:robin} For $i=1$ to $k$ do:
  \item If $P_i\neq \emptyset$, then schedule $p\in {\cal P}(i)$ and remove $p$ from $P_i$.
  \end{enumerate}
\end{enumerate}
The scheduling of a flow path $p\in P_i$ tries to schedule the links in
$p$ one after the other (cyclically) to reduce the time a packet needs to wait in each node
along $p$. The scheduling simply scans the links in $p$ in the order
along $p$, and finds the first feasible time slot (in cyclic order) for
each link $e\in p$.

We point out that in Line~\ref{item:robin}, we schedule one path from
each stream to maintain fairness in allocation and delays. On the average, each stream
suffers from the same ``fragmentation'' problems in the table $A$.

In our experiments, the path-peeling scheduler succeeded in scheduling
\textbf{XXX\%} of the flow. The advantage, compare to the greedy
scheduler, is that delays are significantly reduced.

\section{Flow Control}\label{sec:flow control}
The multi-flow table computed by the algorithm determines the number of packets $\mf(e,s)$
that should be sent along each link $e$ for stream $s$ during each period.
Each node $v$ monitors the following information for each link $e \in \Eout (v)$.
\begin{enumerate}
\item $A(e,s,t)$ - the number of packets belonging to stream $s$ sent
  along the link $e$ during the period $t$.
\item $A^+(e,s,t)$ - the maximum number of packets belonging to stream
  $s$ that can be sent along the link $e$ during the period $t$. Note
  that $A^+(e,s,t)\geq A(e,s,t)$; inequality may happen if the queue
  $Q(e,s)$ is empty when a packet is scheduled to be transmitted along
  the link $e$. Note that if $e$ is not planned to deliver packets of
  stream $s$, then $A^+(e,s,t)=0$.
\end{enumerate}
We remark that a node $v$ can also monitor $A(e,s,t)$ for a link $e\in
\Ein(v)$.  However, the value $A^+(e,s,t)$ for a link $e\in \Ein(v)$
must be sent to $v$ (e.g., by appending it to one of the delivered
packets).

The Flow-Control algorithm is executed locally by all the nodes in the
network. Let $e=(u,v,m)$ denote a link from $u$ to $v$, and let $s$
denote a stream. Each node executes a separate instance per stream.
In the end of each period $t$, each node $u$ ``forwards'' the value of
$A^+(e,s,t)$ to node $v$.  In addition, in the end of each period $t$,
node $v$ sends ``backwards'' the value $R(e,s)$ to $u$. The value
$R(e,s)$ specifies the number of packets from stream $s$ that $v$ is
willing to receive along the link $e$ in the next period
$t+1$.

The Flow-Control algorithm, listed as Algorithm~\ref{alg:FC} equalizes
the incoming and outgoing packet-rates in intermediate nodes as
follows.  The requested packet-rate $R(e,s)$ is initialized to be the
value $\mf(e,s)$ derived from the table.  The Flow-Control algorithm is
activated in the end of each period.  It uses the values $A(e,s,t)$
and $A^+(e,s,t)$ for every link $e$ incident to $v$.  Some of these
values are computed locally and some sent by the neighbors. The
incoming packet-rate $R_{in}$ is computed in line~\ref{line:Rin}, and
is divided among the incoming links in line~\ref{line:Res}. Excess
packets in the queue $Q(v,s)$ are dropped
so that the number of packets in $Q(v,s)$ is at most $R_{in}$. The
rational is that, in the next period, at most $R_{in}$ packets will be
delivered, and hence, excess packets might as well be dropped.

We now elaborate on the boundary cases for the flow-control for a
source $a_s$ and a destination $b_s$ of stream $s$.  The destination
$b_s$ simply sends an infinite request for each incoming link $e\in \Ein(b_s)$, i.e.,
$R(e,s)\gets \infty$.  The source $a_s$, does not execute
line~\ref{line:Res}; instead, it sets the packet-rate of the video
encoder to $R_{in}$.


\begin{algorithm}
  \caption{Flow-Control$(v,s)$ - a local algorithm for managing the
    local queue and requested incoming rate at node $v$ for stream
    $s$.}
\label{alg:FC}
  \begin{enumerate}
  \item Initialize: for all $e\in \Ein(v)$, $R(e,s)\gets \mf(e,s)$.
  \item For $t=1$ to $\infty$ do
    \begin{enumerate}
    \item Measure $A(e,s,t)$ for every $e\in E(v)$, and $A^+(e,s,t)$ for every $e\in\Eout(v)$.
    \item Receive $A^+(e,s,t)$ for every $e\in\Ein(v)$, and $R(e,s)$ for every $e\in \Eout(v)$.
    \item \label{line:Rin}
$R_{in} \gets \min\{\sum_{e\in\Eout(v)} R(e,s),$\\
$ \sum_{e\in\Eout(v)} A^+(e,s,t), \sum_{e\in\Ein(v)} A^+(e,s,t),
            \}$.
          \item \label{line:Res}
For every $e\in\Ein(v)$: $R(e,s) \gets R_{in} \cdot
            \frac{A^+(e,s,t)}{\sum_{e'\in\Ein(v) A^+(e',s,t)}}$.
            \item Drop oldest packets from $Q(v,s)$, if needed, so
              that $|Q(v,s)|\leq R_{in}$.
    \end{enumerate}
  \end{enumerate}
\end{algorithm}

\section{Experimental Results}
\subsection{General Setting}

Tools. CLP, C++, OMNET++/MixiM

Radio. Wifi 802.11g, radiuses., $\alpha=4.1$, fixed transmission power.
$N=-100dBm$.

Video Streams. Packet size.
64 packets per second if stream rate is 1mbps.

Algorithm parameters:
slot length
period
number of freq

simplification in the implementation:
flow control messages are not implemented.

simple implementation:
algorithm only packs one stream per link in each table entry.
(only reduces the performance of the algorithm)

Clean air threshold:
with schedule:
without schedule: 500m

\subsection{Scenarios}
We ran the experiments on two main types of arrangements of the nodes
in the plane: a circle and a grid.

\begin{enumerate}
\item In the grid arrangement, we positioned $49$ nodes in a
  $1km\times 1km$ square. The nodes are positioned in a $7\times 7$
  lattice, so that the horizontal and vertical distance between
  adjacent nodes is $1000/7=142$ meters (see Fig.~\ref{fig:scenario
    grid}).  The source and desitionation of the streams in the grid
  arrangement are chosen randomly.

\item In the circle arrangement, we positioned $25$ nodes on a circle
  of radius $500$ meters.  The nodes were positioned every $360/25$
  degrees (see Fig.~\ref{fig:scenario circle}). The source and
  desitionation of the streams in the circle arrangement are chosen
  deterministically, by $a_i=\lceil 25/k \rceil$, $b_i=(a_i + \lfloor
  25/k \rfloor) \bmod 25$, where $k$ denotes the number of streams.
\end{enumerate}

We point out that random locations of nodes in a square kilometer
induces a communication graph with a high degree and a diameter of
$2-3$. In addition, the interference set of each link contains almost
the other links. Hence, this setting has a low capacity and is not an
interesting setting for the problem we are study.

The requests demand $d^*_i$ is set to $50$mbps. Such a demand with
$k\geq 6$ streams is above the capacity of the network. This enables
us to study the performance in a congested setting.

\subsection{Benchmarks}
We ran the experiments using five algorithms:
\begin{enumerate}
\item \algS - a shortest path maximum bottleneck routing algorithm.
  Let $\pps(\MCS(e))$ denote the number of packets-per-slot in the
  \MCS\ used by the link $e$.  Let $\hops(p)$ denote the number of
  hops along a path $p$. In \algS, the stream $s$ is routed along a
  path $p$ from $a_s$ to $b_s$ such that, for every path $p'$ from
  $a_s$ to $b_s$, the following holds:
  \begin{align*}
    \min_{e \in p} \pps(\MCS(e)) &\geq \min_{e \in p'} \pps(\MCS(e)) \text{ , and}\\
    \min_{e \in p} \pps(\MCS(e)) &= \min_{e \in p'} \pps(\MCS(e))  \\
\Longrightarrow &\hops(p) \leq \hops(p').
  \end{align*}
  The paths assigned to the $k$ streams are divided evenly among the
  three frequency channels.

Each node in this benchmark contains three
  radios. This means that each node contains three standard 802.11g
  WNICs, each working in different frequency channel.  Since the
  frequency channels are non-overlapping, one WNIC may receive while
  another WNIC is transmitting.  Each WNIC receives and transmits
  packets according to the WiFi MAC.  Fairness between the streams is
  obtained as follows.  Each WNIC is given FIFO-queue for each stream,
  the packets of which it needs to transmit. Each WNIC uses a simple
  round-robin policy for determining the queue from which the next
  packet is transmitted.

  The paths are computed in an oblivious manner, namely, congestion
  does not play a role. This means that we must execute a flow control
  algorithm to adjust the data-rate.  To execute the Flow-Control
  algorithm without any changes, we trivially cast this routing to our
  setting as follows.  We define the multi-flow $\mf(e,s)$ to equal
  $d^*_s$ if $e$ is in the path assigned to stream $s$, and $0$
  otherwise. The time-slotted frequecy table $A$ has a single time
  slot (i.e., $T=1$) whose duration is one second. Namely, the table
  $A$ has three entries, one for each frequency channel.  The table
  entry for frequency channel $j$ lists the links that use frequency
  channel $j$.
\item \algA. In the \algA\ benchmark all three parts of our algorithm
  are used: computation of a multicommodity flow with intereference
  constraints, the path-peeling scheduler, and the Flow-Control
  algorithm,

  We emphasize that in this benchmark, each node contains a single
  radio; namely, each node has a single standard 802.11g WNIC capable
  of hopping between the three frequency channels in the beginning of
  each time slot.

\item \algE\ - same as \algA\ except that the LP does not include
  interference constraints. The scheduler resolves interferences, so
  it is interesting to see how much throughput is scheduled by the
  scheduler, and whether this throughput is routed in the simulation.

  We point out that the interference constraints constitute a large
  part of the LP constraints. By omitting them, the LP becomes
  shorter, easier to solves, and naturally, the LP solution has a
  higher flow.

\item \algC\ - same as \algA\ but without the scheduler.  Instead, the
  multi-flows are assigned in a single-slot schedule, as in Algorithm
  \algS. We point out that in this benchmark, each node is equppied
  with three WNICs as in Algorithm \algS.

  The motivation for this benchmark is that the multi-flow takes into
  account congestion and interference. Since the WiFi MAC deals with
  avoiding collisions, so it is interesting to see how it succeeds in
  scheduling the multi-flows in a distributed manner.

\item \algD\ - similar \algS\ except that the the streams are routed
  according to a multi-commodity flow. The multi-commodity flow is
  computed by an LP without intereference constraints.  This benchmark
  helps understand whether non-oblivious congestion aware routing
  improves performance.


\end{enumerate}

\subsection{Results}

\paragraph{Stability}
of throughput

of delay

\paragraph{Effect of number of streams.}

\paragraph{The Flow-Control algorithm}
queue lengths

dropped packets

perturbations in the requested packet-rate per link

suggest other ways to implement the flow-control messages (incorporate
in ACKs, send in the beginning of a time slot, reserve control slots).

\paragraph{PER}

\paragraph{Comparison with greedy scheduler}

\paragraph{Effect of single radio on \algS}


\input{tables12.tex}


\begin{table*}
\centering\small
\begin{tabular}{|| l || c | c | c | c|| c | c || c | c || c | c | c ||}
\hline
& \multicolumn{3}{|c|}{Throughput}  & Delay & \multicolumn{4}{|c||}{Delay\_str} & Hops & Dropes & PER \\
\hline
& min & sum & max & max & \multicolumn{2}{|c||}{max} & \multicolumn{2}{|c||}{min} & avr & max & avr \\
\hline
& Mbps & Mbps & Mbps & sec & \#hops & sec & \#hops & sec & & \% & \% \\
\hline\hline
\algA & 1.616 & 28.24  & 2.688 & 0.47 & 22 & 0.43 & 2 & 0.47 & 3.667 & 0   & 0 \\
\algB & 4.592 & 57.888 & 4.88  & 1.1  & 2  & 1.1  & 2 & 1.1  & 2     & 1   & 0 \\
\algC & 0.72  & 14.784 & 1.76  & 1.95 & 22 & 1.9  & 2 & 1.95 & 3.667 & 14  & 3.52 \\
\algD & 0.576 & 14.736 & 1.888 & 2.25 & 22 & 1.9  & 2 & 2.25 & 3.667 & 17  & 4.02 \\
\algE & 1.042 & 18.537 & 1.823 & 2.3  & 22 & 0.95 & 2 & 2.3  & 3.667 & 0.9 & 0 \\
\hline
\end{tabular}
\caption{Circle 12d}
\label{table_mcs}
\end{table*}


\begin{figure}[h!]
      \centering
        \subfloat[]{\label{fig:small1}\includegraphics[width=0.5\textwidth]{3radio_vs_1radio.eps}}\\
        %\subfloat[]{\label{fig:small2}\includegraphics[width=0.5\textwidth]{avg_delay_greedy_vs_smart.eps}}\\
        \subfloat[]{\label{fig:small3}\includegraphics[width=0.5\textwidth]{fairness_compare.eps}}\\
        \caption{....}
      \label{fig:big1}
     \end{figure}

\begin{figure}[h!]
      \centering
        \subfloat[]{\label{fig:small4}\includegraphics[width=0.5\textwidth]{fc_rate_long_grid_12r_new.eps}}\\
        \subfloat[]{\label{fig:small5}\includegraphics[width=0.5\textwidth]{max_delay_greedy_vs_smart.eps}}\\
        \subfloat[]{\label{fig:small6}\includegraphics[width=0.5\textwidth]{max_drop_in_time_grid_12r.eps}}\\
    \label{fig:big2}
     \end{figure}

\begin{figure}[h!]
      \centering
        %\subfloat[]{\label{fig:small7}\includegraphics[width=0.5\textwidth]{min_tp_vs_num_reqs.eps}}\\
        \subfloat[]{\label{fig:small8}\includegraphics[width=0.5\textwidth]{q_len_max_multi_1_fig.eps}}\\
        \subfloat[]{\label{fig:small9}\includegraphics[width=0.5\textwidth]{throughput_greedy_sched_grid_12r.eps}}\\
 \label{fig:big3}
     \end{figure}

\begin{figure}[h!]
      \centering
        \subfloat[]{\label{fig:small10}\includegraphics[width=0.5\textwidth]{throughput_smart_sched_grid_12r.eps}}\\
        \subfloat[]{\label{fig:small11}\includegraphics[width=0.5\textwidth]{tp_sched_comparison.eps}}\\
        \subfloat[]{\label{fig:small12}\includegraphics[width=0.5\textwidth]{tp_stability.eps}}\\
        \caption{....}
      \label{fig:big4}
     \end{figure}


%%%%%% Scenarios and benchmarks
\begin{figure}%[h!]
      \centering
        \subfloat{\label{fig:small13}\includegraphics[width=0.5\textwidth]{scenario_main_circle_12d.eps}}
        %\subfloat[]{\label{fig:small14}\includegraphics[width=0.5\textwidth]{scenario_mainnosched_circle_12d.eps}}\\
        %\subfloat[]{\label{fig:small15}\includegraphics[width=0.5\textwidth]{scenario_mfnosched_circle_12d.eps}}
        %\subfloat[]{\label{fig:small16}\includegraphics[width=0.5\textwidth]{scenario_mfsched_circle_12d.eps}}\\
        %\subfloat[]{\label{fig:small17}\includegraphics[width=0.5\textwidth]{scenario_short_circle_12d.eps}}\\
        \caption{....}
      \label{fig:big5}
     \end{figure}

\begin{figure}%[h!]
      \centering
        \subfloat{\label{fig:small18}\includegraphics[width=0.5\textwidth]{scenario_main_grid_12r.eps}}
        %\subfloat[]{\label{fig:small19}\includegraphics[width=0.5\textwidth]{scenario_mainnosched_grid_12r.eps}}\\
        %\subfloat[]{\label{fig:small20}\includegraphics[width=0.5\textwidth]{scenario_mfnosched_grid_12r.eps}}
        %\subfloat[]{\label{fig:small21}\includegraphics[width=0.5\textwidth]{scenario_mfsched_grid_12r.eps}}\\
        %\subfloat[]{\label{fig:small22}\includegraphics[width=0.5\textwidth]{scenario_short_grid_12r.eps}}\\
        \caption{....}
      \label{fig:big6}
     \end{figure}


\section{Conclusions}
stable and predictable results that compete well with nodes equipped with $3$ radios.



\section{Discussion}
central algorithm - relies on an established network.
algorithm may be computed in multiple nodes (deterministic, will outcome the same results)
distribution of tables via broadcast is easy (small tables)

Formulated a new problem: scheduling of multi-flows to reduce
end-to-end delay.

future:
mobile users - how fast does performace degrade?
Consider continuous recomputations of tables with expiration times.

consider approximate distributed multi-commodity flow algorithms


%
\ifnum\conff=0
  \subsection*{Acknowledgments}
  We thank Nissim Halabi for useful discussions.
\fi
%

%\nocite{*}
\bibliographystyle{alpha}
\bibliography{wireless}

\newpage
\appendix
\end{document}
