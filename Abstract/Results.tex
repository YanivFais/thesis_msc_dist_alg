%last minute:
%2 col
%check abstract


\def\conff{1}
%\def\conff{0}

\ifnum\conff=0
\documentclass[12pt]{article}
\fi

\ifnum\conff=1
\documentclass{sig-alternate-10pt}
\fi

\usepackage{times}
\usepackage{url}
\usepackage{comment}
\usepackage[english]{babel}
\usepackage{array}

%\usepackage{float}
%\floatstyle{ruled}
\usepackage{algorithm}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{graphicx}
\graphicspath{{./Figs/}}

\usepackage{paralist}

\ifnum\conff=0
\usepackage[active]{srcltx}
\usepackage[a4paper]{geometry}
\geometry{hmargin=1in,top=1in}
\usepackage{setspace}%\singlespacing

\usepackage{amsthm}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{theoremnonum}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{coro}[theorem]{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{observation}{observation}
\newtheorem{definition}{Definition}


\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \newcommand{\qed}{$\blacksquare$}
% \newenvironment{proof}{\noindent {\bf Proof:} }{\hfill \qed}
\newenvironment{proof sketch}[1]{\noindent {\emph{Proof sketch of #1:}}}{\hfill \qed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\newenvironment{proof}{\noindent {\bfseries Proof.} }
%  {\mbox{}\nolinebreak \hfill \qed}
\newcommand{\eps}{\varepsilon}

\newcommand{\flow}{\text{\emph{flow}}}
\newcommand{\poly}{\text{\emph{poly}}}
\newcommand{\source}{\text{\emph{source}}}
\newcommand{\target}{\text{\emph{target}}}
\newcommand{\demand}{\text{\emph{demand}}}
\newcommand{\reject}{\text{\emph{reject}}}
%\newcommand{\load}{\text{\emph{load}}}
%\newcommand{\far}{R^{\text{\emph{Far}}}}
%\newcommand{\near}{R^{\text{\emph{Near}}}}
\newcommand{\opt}{\text{\textsc{opt}}}
\newcommand{\iopt}{I^*}
%\newcommand{\alg}{\textit{Alg}}
%\newcommand{\algf}{\textit{Alg}_{\text{\textit{far}}}}
%\newcommand{\algn}{\textit{Alg}_{\text{\textit{near}}}}
\newcommand{\eqdf}{\triangleq}

\newcommand{\SINR}{\text{\sc{sinr}}}
\newcommand{\SNR}{\text{\sc{snr}}}
\newcommand{\PER}{\text{\sc{per}}}
\newcommand{\pps}{\text{\emph{pps}}}
\newcommand{\hops}{\text{\emph{hops}}}
\newcommand{\mf}{\text{\emph{mf}}}
\newcommand{\MCS}{\text{\sc{mcs}}}
\newcommand{\Ein}{E_{\text{\emph{in}}}}
\newcommand{\Eout}{E_{\text{\emph{out}}}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\Imodel}{$\cal{I}$}

\newcommand{\algA}{\textsc{MF-I-S}}
\newcommand{\Alg}{\algA}
\newcommand{\algB}{\textsc{ShortP}}
\newcommand{\algC}{\textsc{MF-I}}
\newcommand{\algD}{\textsc{MF}}
\newcommand{\algE}{\textsc{MF-S}}

\newcommand{\algS}{\algB}

\begin{document}
%\begin{titlepage}
\title{Real-Time Video Streaming in Multi-hop Wireless Static Ad Hoc Networks}

\ifnum\conff=0
\author{%
Guy Even\thanks{School of Electrical Engineering,
Tel-Aviv Univ., Tel-Aviv 69978, Israel.
\protect\url{{guy,medinamo,moni,sasha}@eng.tau.ac.il}}
\and
Yaniv Fais$^*$
\and
Moti Medina$^*$
%
\and Shimon (Moni) Shahar$^*$
\and Alexander Zadorojniy$^*$ }
\fi
\date{}

\maketitle


%%% ----------------------------------------------------------------------

\begin{abstract}
  In this paper we deal with the problem of streaming multiple video
  streams between pairs of nodes in a multi-hop wireless ad hoc
  network.  The nodes are positioned on a plane, know their locations,
  and are synchronized (via GPS). We consider a 802.11g WiFi network
  in which NICs can hop between non-overlapping frequency channels in
  a synchronous fashion. Our goal is to maximize the minimum
  throughput over all the video streams. We designed a centralized
  algorithm that computes a channel/time-slot table.  Each entry in
  the table specifies the active links.

  Our algorithm constructs a communication graph based on distances.
  For each link in the communication graph, a set of interfering links
  is defined based on distances and the SNR of the link.  A
  multicommodity flow with interference constraints is solved by
  linear programming. The flow is then rounded to obtain the
  channel/time-slot table. After the table is broadcast, each node
  receives and transmits according to the table. In addition, we developed a localized
  flow-control mechanism to stabilize the queue lengths.

  We simulated our algorithm using OMNET++/MixiM (i.e., physical SINR
  interference model) to test whether the computed throughput is
  achieved. Our results show that we are able to route 95\% of the
  computed throughput.
\end{abstract}

\begin{comment}
  \paragraph{ Keywords:}
\end{comment}

%\end{titlepage}
\section{Introduction}

\paragraph{Special characteristics of real-time video streaming}
Streaming of real-time video in a multi-hop ad hoc network is a
challenging task.  We briefly overview these unique characteristics.
\begin{inparaenum}[(1)]
%  \item Video coding (e.g., H.264/MPEG) creates a bursty stream since
%    I-frames are much longer than the other frames. One could smoothen
%    the stream at the cost of incurring a extra delay of a second
%    (i.e., the time between I-frames).
\item End-to-end delay in streaming of real-time video should be as
  small as possible.  We assume that a delay of $1$-$2$ seconds is
  tolerable if the video has to travel across $10$ hops.  One
  implication of this constraint is that end-to-end acknowledgments and TCP are
  not an option.
\item Unless erasure codes are employed, loosing even a small fraction
  of the packets incurs an intolerable degradation in the video
  quality. We assume that video has acceptable quality if less that
  $0.5\%$ of the packets are dropped. In wireless networks, each link
  can have a \PER\ of $1\%$-$5\%$. Thus, after $10$ hops, one is left
  with intolerable erasures.  On the other had, erasure codes incur an
  extra end-to-end delay since they need to accumulate data for a
  block before encoding can take place. This means that relying on
  WiFi acknowledgments and retransmit capabilities can be useful to
  avoid packet drops if the \PER\ is small.
\item A useful feature in video coding is the ability to adjust the
  compressed bit-rate. This means that the video encoder can be
  continuously controlled to generate a video stream of a requested
  bit rate. We rely on this feature in our flow control algorithm.
  This feature separates video streaming from other applications such
  as FTP.
\end{inparaenum}
The necessity of cross layer designs has been recognized for
satisfying the special characteristics of real-time video streaming
over wireless
networks~\cite{shan2005cross,setton2005cross,khan2006application}.  We
continue this line of work.
\paragraph{Previous Work}

\paragraph{Our Contributions}
\begin{enumerate}
\item To evaluate our algorithm we perform a simulation of real-time
  video streaming in a standard 802.11g setting using OMNET++/MixiM
  (Sec.~\ref{sec:exp}).  In this setting, all WiFi frames are
  transmitted (i.e., RTS,CTS, packet, ACK), and interferences between
  frames are analyzed using the SINR and the MCS.
\item We introduce a new interference model that is an intermediate
  model between the physical \SINR-model and the graph based protocol
  model (Sec.~\ref{sec:models}). The interference set of a link is a
  function of the signal-to-noise ratio of the link and the \MCS\ of
  the link.  As the link is closer to the \SINR-threshold, the
  interference set grows, so that \SINR\ is not in the ``waterfall''
  region of the \PER\ function.  One advantage of this new
  interference model is that it is easy to formulate interference
  constraints in the linear program formulation (Sec.~\ref{sec:LP}).
\item We formulate the problem of minimizing end-to-end delay due to a
  schedule that supports a given multi-flow. We developed and
  implemented a scheduler algorithm that address this problem of
  reducing end-to-end delays while supporting a similar throughput.
  (Sec~\ref{sec:sched}).
\item We developed and implemented a flow control algorithm that
  stabilizes the queue lengths and controls the data-rate along the
  links.  This flow control algorithm is executed locally by the
  nodes.
\item We combine the various aspects of video streaming to analyze
  performance that is crucial for real-time video streaming.  Namely,
  we measured the throughput, end-to-end delay, fraction of dropped
  packets, and the stability of these parameters.
\end{enumerate}

\paragraph{Techniques}
\textbf{KEEP?}
The algorithm computes two tables: a multi-flow table $\mf$ and a
time-slotted frequency table $A$ that governs communication in the
network. Each entry $A[j,t]$ of the table is indexed by a frequency
channel $j$ and a time slot $t$ pair.  The set of links that appear in
$A[j,t]$ are supposed to deliver packets in time slot $t$ using the
frequency channel $j$.


 The algorithm computes a
\paragraph{Organization}

\section{Problem Definition}\label{sec:problem}
\paragraph{Setting}
We consider a WiFi 802.11g static ad hoc network with $3$ non-interfering radio
channels with the assumptions:
\begin{inparaenum}[(i)]
\item Single radio: each node has a single wireless network interface
  controller (WNIC).
\item Each node is equipped with a GPS so that it knows
  its location and the nodes are synchronized.
\item The WNICs support quick synchronized hops between frequency
  channels.
\item Isotropic antennas.
\item We also assume that the nodes have already joined the network
  and that there is at least one node (i.e., center node) that holds
  full information about the network (i.e., nodes and locations).
  Accumulating this information can be done in a distributed
  low-bandwidth fashion after building a spanning
  tree~\cite{awerbuch1987optimal}.
\end{inparaenum}




\paragraph{Problem Definition}
The input to the algorithms consists of:
\begin{enumerate}
\item A set $V$ of $n$ nodes in the plane. A transceiver is located in
  each node.
\item A set of $k$ video stream requests $\{r_i\}_{i=1}^k$. Each
  stream request is a triple $r_i\eqdf (a_i,b_i,d^*_i)$, where $a_i$ is
  the source (e.g., camera) of the stream, $b_i$ is the destination,
  and $d^*_i$ is the required data-rate.
\end{enumerate}
Ideally, we would like to satisfy all the requests, namely, for each
video stream $r_i$, route packets using multi-hops from $a_i$ to $b_i$.
We assume that there is there is a path in the network between each
source-destination pair.

Let $d_i$ denote the data-rate achieved for the $i$th stream.  The
service ratio $\rho_i$ of the $i$th demand is defined by $\rho_i \eqdf
d_i/d^*_i$.  Our goal is to maximize the minimum service ratio,
namely, $\max \min_i \rho_i$.

Additional performance measures are:
\begin{inparaenum}[(i)]
\item End-to-end delay - this is the time it takes a packet to reach
  its destination. We are interested in reducing the maximum delay
  (among the packets that are delivered) since the video is real-time.
  In addition, the maximum delay determines the size of the jitter
  buffer in the receiving side.
\item Number of dropped packets. Queue management may drop packets
  that never reach their destination.
\item Queue lengths in intermediate nodes tell us how much memory
  should be allocated and also give an indication of the delay per hop.
\end{inparaenum}

\section{Preliminaries}
\label{sec:prelim}

\subsection{Interference Models}

\paragraph{Bidirectional interference}
The delivery of a message in the WiFi MAC requires transmission of
frames by both sides (e.g., RTS and packet are transmitted by the
sender, CTS and ACK are transmitted by the receiver). Hence,
interferences can be caused also by frames transmitted by a the
receiving side.

\noindent
We outline the three interference models below.
\paragraph{The SINR model}
The SINR model, also called the physical
interference model, defines successful communication as follows.  Let
$d_{u,v}$ denote the distance between nodes $u$ and $v$.  Suppose a subset
$S_t\subseteq V$ of the nodes are transmitting simultaneously in the
same frequency channel as $u$.  The signal-to-interference-plus-noise
ratio (SINR) for the reception by $v\in V\setminus S_t$ of the signal
transmitted by $u\in S_t$ in the presence of the transmitters $S_t$ is
defined by
\[
\SINR(u,v,S_t) \eqdf \frac{P/d_{u,v}^{\alpha}}{N+\sum_{x\in
    S_t\setminus{u}} P/d_{x,v}^{\alpha}}.
\]
Each transmitter can use one of several modulation coding schemes (\MCS).
The message transmitted by $u$ in an \MCS\ $m$ is successfully received by
$v$ if $\SINR(u,v,S_t)\geq \beta_m$, where $\beta_m$ is the minimum
SINR-threshold for the \MCS\ $m$.

\paragraph{Protocol model}
The protocol model, also called the graph model, is specified by two
radii:
\begin{inparaenum}[(i)]
\item A communication distance $r$.
\item An interference distance $R$.
\end{inparaenum}
The rule for successful communication between two nodes $u$ and $v$ is
that $v$ receives the message from $u$ if $d_{u,v}<r$ and every node
$x$ that transmits at the same time satisfies $d_{xv}> R$.  In this
model, a communication graph is defined over the nodes.  Two nodes are
linked by an edge if their distance is less than the communication
distance $r$.

Since the WiFi MAC requires transmission by both sides, an
\emph{interference} is defined between two links $(u,v)$ and $(u',v')$
if $\min\{d_{u,u'},d_{u,v'}, d_{v,u'}, d_{v,v'}\} < R$.  We say that a
subset $L$ of links is \emph{non-interfering} if no two links in $L$
interfere.  In the protocol model, a \emph{schedule} is a sequence
$\{L_i\}_i$ of subsets of non-interfering links.


\paragraph{The new model}
The new model is an intermediate model between the SINR model and the
protocol model. The idea is that, as the \SNR\ of a link grows, the
link can tolerate more interference. Hence, the interference distance
is not fixed.

Consider a pair $(u,v)$ of nodes and an \MCS\ $m$.
The triple $(u,v,m)$ is a \emph{link} in the new model if
$\SINR(u,v,\emptyset) \geq \beta_m$.

Since both sides of a link transmit and receive, the interference set
of a link must take into account interferences caused by other
transmissions both in the receiver and the sender. However, the frames
sent by the receiving side are in \MCS\ $0$, therefore, reception of
these frames depends on the $\SINR$-threshold $\beta_0$.

The interference set $V_{u,v,m}$ of the link $e=(u,v,m)$ is defined by
  \begin{align*}
    V_{u,v,m} \eqdf \left\{ x \in V \setminus\{u\}\right. &\left | \SINR(u,v,\{x\}) \geq \mu  \cdot \beta_i \text{ or } \right. \\
    & \left.\SINR(v,u,\{x\}) \geq \mu \cdot \beta_0\right\}.
\end{align*}
The motivation for this definition is that transmissions of nodes in $V_{u,v,m}$ interfere with
the reception of $v$ by $u$, or vice versa.
The choice of $\mu=1.585$ gives us a margin of $2$dB above the
\SINR-threshold.  This margin keeps the $\SINR$ above the threshold
due to interferences caused by transmitters not in $S_{u,v,m}$.

We also define the interfering set of edges with respect to the link $e=(u,v,m)$.
\begin{align*}
  I_{u,v,m} \eqdf \{ e'=(u',v',m') \mid &\{u',v'\} \cap (V_{u,v,m} \cup V_{v,u,m})
\\
& \neq \emptyset\} \setminus \{(u,v,m)\}.
\end{align*}
The interference set $I_{u,v,m}$ contains a link $e'$ if either
endpoint of $e'$ interferes with reception at the endpoints $u$ or
$v$.

\begin{comment}
  \begin{align*}
    S_{u,v,m} &\eqdf \left\{ x \in V \left | \frac{1}{6}\cdot
        \frac{P}{d_{x,v}^{\alpha}} > \left( \frac{P}{\beta\cdot
            d_{u,v}^{\alpha}} - N \right) \right.  \right\}
  \end{align*}
The justification for the definition of the interference set is summarized in the following claim.
\begin{claim}
Suppose $S_t$ is ``feasible''.
If $S_t \cap S_{u,v,m}=\emptyset$ then
$\SINR(u,v,S_t) \geq \SINR (u,v,\emptyset) \cdot \gamma.$
\end{claim}
\end{comment}

\subsection{Notation}

Let $u$ and $v$ denote nodes and $m$ denote an \MCS.  A link is a
triple $(u,v,m)$ such that $\SINR(u,v,\emptyset)\geq \beta_m$.  This
definition implies that there can be multiple parallel links between
$u$ and $v$, each with a different \MCS.

We denote the set of links by $E$. The set $\Eout(v)$ (resp.
$\Ein(v)$) denotes the set of links that emanate from (resp. enter)
$v$. Let $E(v)$ denote the set of links $\Ein(v)\cup \Eout(v)$.

For a link $e=(u,v,m)$, let $\MCS(e)=m$, i.e., the \MCS\ $m$ of the link $e$.



\section{Algorithm}\label{sec:outline}
\subsection{Networks Governed by Time-Slotted Frequency Tables}
Two tables govern the communication in the network.  The first table
$A$ is a time-slotted frequency table. The dimensions of $A$ are
$F\times T$, where $F$ denotes the number of frequency channels and
$T$ denotes the number of time slots.  There is one row for each
frequency channel and one column for each time slot. (In our
implementation we used $F=3$ and $T=200$).  The table $A$ determines a
periodic schedule.  The second table is a multi-flow table $\mf$. The
dimensions of $\mf$ are $|E|\times [1..k]$ (recall that $k$ equals the
number of video streams).  The entry $\mf(e,s)$ specifies the number
of packets-per-period that should be delivered along link $e$ for
stream $s$.

Each table entry $A[j,t]$ is a subset of links,
i.e., $A[j,t]\subseteq E$.  The table governs communication in the
sense that, in slot $t'$, the links in $A[j,t' \pmod T]$ try to deliver packets
using frequency channel $j$.

We use $A[\cdot,t]$ to denote the set of links $\cup_{j\in F}
A[j,t]$.  Since we assume that each node is equipped is a single
radio, it follows that two links that share an endpoint cannot be
active in the same time slot.  Hence, for every node $v$, $E(v) \cap
A[\cdot ,t]$ may contain at most one link.

Algorithm \Alg\ computes a time-slotted frequency table that supports
a multi-flow (see Sec.~\ref{sec:output}). A time-slotted frequency
tables schedules active links as listed in Algorithm~\ref{alg:tx-rx}.
Each node $v$ executes Algorithm TX-RX$(v)$ locally.  Since $E(v) \cap
A[\cdot ,t]$ may contain at most one link, a node $v$ is either a
receiver, a sender, or inactive in each time slot.  We elaborate below how
a queue $Q(v,s)$ with the highest priority for transmission along link
$e$ in line~\ref{line:priority} in the Transmit procedure is defined.

Upon invocation of Transmit$(e,j)$, where $e=(v,u,m)$, the node $v$
needs to decide which packet to transmit. The node $v$ uses the
multi-flow table $\mf$ to determine the set $S_e$ of streams that are
routed along $e$.  Since delay is a major issue, it is reasonable to
use an EDD-like policy, i.e., pick the oldest packet in the queues
$Q(v,s)$, for $s\in S_e$.  However, such a policy ignores the
remaining number of hops a packet needs to traverse. We prefer the
approach that emphasizes fairness. That is, assign a priority that
equals the ratio of the number of packets of stream $s$ transmitted
along $e$ in the last period divided by the required number. The lower
this ratio, the higher priority of the stream. This approach also
combines well with the flow control algorithm described in
Sec.~\ref{sec:flow control}.


\begin{algorithm}
  \caption{TX-RX$(v)$ - a local transmit-receive algorithm for node
    $v$ as specified by a time-slotted frequency table $A$.}
\label{alg:tx-rx}
For time slot $t'=0$ to $\infty$ do
  \begin{enumerate}%1
\item $t = t' \pmod T$.
  \item if $\Ein(v)\cap A[\cdot,t ]\neq \emptyset$ then
    \{reception mode\}
    \begin{enumerate}%2
    \item Let $e\in \Ein(v)\cap A[\cdot,t]$, where $e(u,v,m)\in
      A[j,t]$.
    \item While slot $t$ is not over call Receive$(e,j)$.
    \end{enumerate}%2
  \item if $\Eout(v)\cap A[\cdot,t ]\neq \emptyset$ then
    \{transmission mode\}
    \begin{enumerate}%2
    \item Let $e\in \Eout(v)\cap A[\cdot,t ]$, where
      $e(v,u,m)\in A[j,t]$.
    \item While slot $t$ is not over call Transmit$(e,j)$.
    \end{enumerate}%2
  \end{enumerate}%1
Receive$(e,j)$ - where link $e=(u,v,m)$ and $j$ is a frequency channel.
\begin{enumerate}
\item Set tuner to reception in frequency channel $j$.
\item Upon reception of a packet $p$ from stream $s$, insert $p$ to $Q(v,s)$.
\end{enumerate}

Transmit$(e,j)$-  where link $e=(v,u,m)$ and $j$ is a frequency channel.
\begin{enumerate}
\item Set tuner to transmission in frequency channel $j$.
\item\label{line:priority} Pick a queue $Q(v,s)$ with a highest priority for transmission along $e$.
\item $p \gets DEQUEUE(Q(v,s))$.
\item Transmit $p$ along $e$.
\end{enumerate}
\end{algorithm}

\subsection{Algorithm Specification}
\paragraph{Input}
The input to Algorithm \Alg\ consists of the following:
\begin{enumerate}
\item A set $V\subseteq \RR^2$  of nodes in the plane.
\item A set of $k$ video stream requests $\{r_i\}_{i=1}^k$. Each
  request $r_i$ is a triple $r_i\eqdf (a_i,b_i,d^*_i)$, where $a_i$ is
  the source (e.g., camera) of the stream, $b_i$ is the destination,
  and $d^*_i$ is the required data-rate.
\end{enumerate}
\paragraph{Output}
\label{sec:output}
The output of Algorithm \Alg\ consists of two parts:
\begin{inparaenum}[(i)]
\item a time-slotted frequency table $A$, and
\item a multi-flow $\mf(e,s)$, for every link $e$ and stream $1\leq
  s\leq k$.
\end{inparaenum}
We note that the units of flow are packets-per-period, where the
period is the duration of a time slot times the number $T$ of
time-slots in a period.

The multi-flow $\mf(e,s)$ determines the routing and the throughout of
each stream. The role of the frequency/time-slot table $A$ is to
specify a periodic schedule that determines which links are active in
which time slots.

Although we use fixed length packets (e.g., 2KB), the \MCS\ of a link
determines the amount of time required for completing the delivery of
a packet.  This means, that within one time slot, multiple packets may
be delivered along a single link.  Let $\pps(e)$ denote the number of
packets-per-slot that can be delivered along $e$.  Namely, node $u$
can transmit at most $\pps(e)$ packets to node $v$ along link
$e=(u,v,m)$ in one time-slot. Note that the value of $\pps(e)$ is a function of
the \MCS\ of the link $e$.

\medskip \noindent
The table $A$ should satisfy the following properties:
\begin{enumerate}
\item Every entry $A[j,t]$ in the table is a set of non-interfering
  links (in an interference model \Imodel). Thus the links in $A[j,t]$
  may be active simultaneously.
\item The data-rates $\mf(e,s)$ are supported by the table. Namely,
  \begin{align*}
    \sum_{s=1}^k \mf(e,s) \leq |\{A[j,t] \mid e\in A[j,t]\}|\cdot \pps(e),
  \end{align*}
\end{enumerate}

\subsection{Algorithm Description}
The algorithm consists of two parts: (i)~computation of a
multi-commodity flow with conflict constraints, and (ii)~scheduling of
the multi-commodity flow in a time-slotted frequency table.
We elaborate on each of these parts.

\paragraph{Multi-commodity flow with conflict constraints}
We formulate the problem of routing and scheduling the video streams
by a linear program (LP).  A similar LP is used
in~\cite{alicherry2005joint11,buragohain2007improved} with respect to
the protocol interference model.  We use our new interference model
for the interference constraints.

For each requested stream $r_i$, we define the supply ratio $\rho_i$
to be the ratio between the flow allocated to the $i$'th stream and
the demand $d^*_i$ of the stream.  The objective of the LP is to
maximize $\min_i \rho_i$.  A secondary objective is to maximize the
total throughput.

Let $c(e)$ denote the number of packets-per-period that can be
delivered along the link $e$ in one period.  As in the case of
$\pps(e)$, the vlaue of $c(e)$ is a function of the \MCS\ of $e$.
However, $c(e)$ may be a non-integer, while $\pps(e)$ is an integer.

\begin{figure*}
  \begin{align}
    \max ~~~\rho + \lambda \cdot\sum_{i=1}^k d^*_i \cdot \rho_i~~~~~~&\text{subject to}&\\
    f^j_i(e) &\geq 0&\forall i\in [1..k], \forall j\in [1..3], \forall e\in E \label{eq:pos}\\
    \sum_{j=1}^3 f_i^j(e) &=f_i(e)& \forall e\in E\label{eq:freq1}\\
    \sum_{i=1}^k f_i^j(e) &=f^j(e)& \forall e\in E\label{eq:freq2}\\
    \sum_{e \in \Eout (v)} f_i(e) - \sum_{e \in \Ein (v)} f_i(e) &=0 &\forall i\in [1..k],\forall v\in V\setminus \{a_i,b_i\}\label{eq:conservation}\\
    \sum_{i=1}^k f_i(e) &\leq c(e) &\forall e\in E \label{eq:cap}\\
    \sum_{e \in \Eout (v)} f_i(a_i) - \sum_{e \in \Ein (v)} f_i(a_i)&=d^*_i \cdot \rho_i &\forall i\in [1..k]\label{eq:rho_i}\\
    \rho &\leq \rho_i&\forall i\in 1..k]\label{eq:rho}\\
    \frac{f^j(e)}{c(e)} + \sum_{j'< j} \sum_{e'\in E(u)\cup E(v)}
    \frac{f^{j'}(e')}{c(e')} + \sum_{e' \in I_{e}}
    \frac{f^j(e')}{c(e')} & \leq 1 & \forall e=(u,v,m)\in E,\forall
    j\in[1..3] \label{eq:conf}
  \end{align}
\end{figure*}
The main variables of the LP are the flow variables $f_i^j(e)$ which
signify the amount of flow along link $e$ in frequency channel $j$
for stream $i$.  In Eq.~\ref{eq:pos} we require that the flows are
nonnegative.  In Eq.~\ref{eq:freq1} we define $f_i(e)$ to be the
combined flow along $e$ for stream $i$ over all frequency channels.  In
Eq.~\ref{eq:freq2} we define $f^j(e)$ to be the combined flow along
$e$ in frequency channel $j$ over all $k$ streams.
Eq.~\ref{eq:conservation} is simply a flow conservation constraint for
stream $i$ in every intermediate node.  Eq.~\ref{eq:cap} is simply a
capacity constraint for every link.  In Eq~\ref{eq:rho_i}, the supply
ratio $\rho_i$ is defined to be the fraction of the demand for stream $i$
that is supplied.  In Eq.~\ref{eq:rho}, $\rho$ is defined to equal the
minimum supply ratio, i.e., $\rho=\min_i \rho_i$.  Finally, in
Eq.~\ref{eq:conf} the interference constraints are defined; we
elaborate on them below.

The objective is to maximize the minimum supply ratio $\rho$.  As a
secondary objective, we maximize the sum of flows.
Therefore, the constant $\lambda$ in the objective function is small
(e.g., $\lambda=1/20)$.

The left-hand-side of the interference constraint consists of three
addends. The first addend $f^j(e)/c(e)$ is the fraction of the time
that the link $e$ is active in transmission in frequency $j$. The
second addend is the fraction of time that the endpoints of $e$ are
active in transmissions in frequencies less than $j$.  Finally, the
third addend is the fraction of time in which links in the
interference set $I_e$ are active in transmissions in frequency $j$.
Recall that each node has a single radio.  This implies that the
fractions in the last two addends correspond to transmissions that may
not take place simultaneously with transmissions in the $j$th
frequency channel of link $e$.

We point out that the capacity constraints in Eq.~\ref{eq:cap} are
redundant since they are implied by the interference constraints in
Eq.~\ref{eq:conf}.

In our experiments, we noticed that the LP-solver found a solution
with flow cycles. We removed these cycles before applying the
scheduling step.  Interestingly, the issue of flow cycles was not
mentioned in previous
works~\cite{alicherry2005joint11,buragohain2007improved}


\paragraph{Scheduling of the multi-commodity flow in a time-slotted
  frequency table}
In the scheduling step we are given the multi-commodity flows
$f^j_i(e)$.  The task is to allocate entries in a
time-slotted frequency table $A$ for these flows.

We first determine how many time-slots should be allocated for
$f^j(e)$, for each link $e$ and each frequency channel $j$.  Recall
that a unit of flow is one packet-per-period.  Recall also that $\pps(e)$
denotes the number of packets-per-slot that can be delivered along
link $e$.   This means that the number of time slots in which
$e=(u,v,m)$ should be allocated in frequency channel $j$ must be at
least
\begin{align*}
  |\{ t\in[1..T] :e\in A[j,t]\}| \cdot \pps(e) &\geq f^j(e)
\end{align*}
Hence,
\begin{align}\label{eq:req}
  |\{ t\in[1..T] :e\in A[j,t]\}| \geq \left\lceil \frac{f^j(e)}{\pps(e)} \right\rceil.
  \end{align}
\paragraph{The greedy scheduler}
  The simplest way to assign flows to the table $A$ is by applying a
  greedy algorithm.  The greedy algorithm scans the links and
  frequency channels, one by one, and assigns $\ell(e,j)$ slots to
  each link $e$ and frequency channel $j$.  Based
  on~\cite{alicherry2005joint11,kumar2004end,buragohain2007improved},
  the interference constraints in Eq.~\ref{eq:conf} imply that the
  greedy algorithm succeeds in this assignment provided that
\begin{align}\label{eq:guar}
 \ell(e,j) = \left\lfloor \frac{f^j(e)}{\pps(e)} \right\rfloor.
  \end{align}
  The issue of dealing with this rounding problem (i.e., the
  difference between the round-down and the round-up in Eqs.~\ref{eq:req} and~\ref{eq:guar}) is discussed
  in~\cite{wan2009multiflows}, where it is pointed out that routing
  all the flow requires a super exponential period $T$. Such a period
  is obviously not practical; the computation of the table takes too
  long, the table is too long to be broadcast to all nodes, and
  the schedule will incur huge delays.

  We show that the rounding problem is not an important issue both
  theoretically and in practice.  Since each flow $f_i$ can be
  decomposed into at most $|E|$ flow paths, it follows that the values
  of $\{f^j_i(e)\}_{e\in E, j\in F}$ can be ``rounded'' so that at
  most $|E|\cdot \max_e \{\pps(e)\}$ packets are lost.  Note that this
  lost flow is bounded by a constant. By increasing the period $T$,
  the amount of flow tends to infinity, and hence, the lost flow is
  negligible. In our experiments~\ref{sec:exp}, we used a period of
  $T=200$ time slots, with a duration of $5ms$ per slot. The greedy
  scheduler was able to schedule almost all the flow in all the
  instances we considered.  The multi-flow table is set so that
  $\mf(e,s)$ equals the amount of flow from $f_s(e)$ that the
  scheduler successfully assigned.

 The greedy scheduler incurred a delay roughly of
  one period per hop. The reason is that it schedules all the
  receptions to a node before the transmissions from the node. To
  avoid this delay, we designed a new scheduler, described below.

\paragraph{The path-peeling scheduler}
The path peeling scheduler tries to reduce the time that an incoming
packet waits till it is forwarded to the next node. This is achieved
as follows.
\begin{enumerate}
\item Decomposes each flow $f_i$ into flow paths such that the flow
  along each path equals the bottleneck, i.e., the minimum $\pps(e)$ along the path.  Let
  $\{f_i(p)\}_{p\in {\cal{P}}(i)}$ denote this decomposition.
\item While not all the flow is scheduled,
  \begin{enumerate}
  \item \label{item:robin} For $i=1$ to $k$ do:
  \item If $P_i\neq \emptyset$, then schedule $p\in {\cal P}(i)$ and remove $p$ from $P_i$.
  \end{enumerate}
\end{enumerate}
The scheduling of a flow path $p\in P_i$ tries to schedule the links in
$p$ one after the other (cyclically) to reduce the time a packet needs to wait in each node
along $p$. The scheduling simply scans the links in $p$ in the order
along $p$, and finds the first feasible time slot (in cyclic order) for
each link $e\in p$.

We point out that in Line~\ref{item:robin}, we schedule one path from
each stream to maintain fairness in allocation and delays. On the average, each stream
suffers from the same ``fragmentation'' problems in the table $A$.

In our experiments, the path-peeling scheduler succeeded in scheduling
\textbf{XXX\%} of the flow. The advantage, compare to the greedy
scheduler, is that delays are significantly reduced.

\section{Flow Control}\label{sec:flow control}
The multi-flow table computed by the algorithm determines the number of packets $\mf(e,s)$
that should be sent along each link $e$ for stream $s$ during each period.
Each node $v$ monitors the following information for each link $e \in \Eout (v)$.
\begin{enumerate}
\item $P(e,s,t)$ - the number of packets belonging to stream $s$ sent
  along the link $e$ during the period $t$.
\item $P^+(e,s,t)$ - the maximum number of packets belonging to stream
  $s$ that can be sent along the link $e$ during the period $t$. Note
  that $P^+(e,s,t)\geq P(e,s,t)$; inequality may happen if the queue
  $Q(e,s)$ is empty when a packet is scheduled to be transmitted along
  the link $e$. Note that if $e$ is not planned to deliver packets of
  stream $s$, then $P^+(e,s,t)=0$.
\end{enumerate}
We remark that a node $v$ can also monitor $P(e,s,t)$ for a link $e\in
\Ein(v)$.  However, the value $P^+(e,s,t)$ for a link $e\in \Ein(v)$
must be sent to $v$ (e.g., by appending it to one of the delivered
packets).

The Flow-Control algorithm is executed locally by all the nodes in the
network. Let $e=(u,v,m)$ denote a link from $u$ to $v$, and let $s$
denote a stream. Each node executes a separate instance per stream.
In the end of each period $t$, each node $u$ ``forwards'' the value of
$P^+(e,s,t)$ to node $v$.  In addition, in the end of each period $t$,
node $v$ sends ``backwards'' the value $R(e,s)$ to $u$. The value
$R(e,s)$ specifies the number of packets from stream $s$ that $v$ is
willing to receive along the link $e$ in the next period
$t+1$.

The Flow-Control algorithm, listed as Algorithm~\ref{alg:FC} equalizes
the incoming and outgoing packet-rates in intermediate nodes as
follows.  The requested packet-rate $R(e,s)$ is initialized to be the
value $\mf(e,s)$ derived from the table.  The Flow-Control algorithm is
activated in the end of each period.  It uses the values $P(e,s,t)$
and $P^+(e,s,t)$ for every link $e$ incident to $v$.  Some of these
values are computed locally and some sent by the neighbors. The
incoming packet-rate $R_{in}$ is computed in line~\ref{line:Rin}, and
is divided among the incoming links in line~\ref{line:Res}. Excess
packets in the queue $Q(v,s)$ are dropped
so that the number of packets in $Q(v,s)$ is at most $R_{in}$. The
rational is that, in the next period, at most $R_{in}$ packets will be
delivered, and hence, excess packets might as well be dropped.

We now elaborate on the boundary cases of the flow-control for a
source $a_s$ and a destination $b_s$ of stream $s$.  The destination
$b_s$ simply sends an fixed request for each incoming link $e\in \Ein(b_s)$, i.e.,
$R(e,s)\gets \mf(e,s)$.  The source $a_s$, does not execute
line~\ref{line:Res}; instead, it sets the packet-rate of the video
encoder to $R_{in}$.


\begin{algorithm}
  \caption{Flow-Control$(v,s)$ - a local algorithm for managing the
    local queue and requested incoming rate at node $v$ for stream
    $s$.}
\label{alg:FC}
  \begin{enumerate}
  \item Initialize: for all $e\in \Ein(v)$, $R(e,s)\gets \mf(e,s)$.
  \item For $t=1$ to $\infty$ do
    \begin{enumerate}
    \item Measure $P(e,s,t)$ for every $e\in E(v)$, and $P^+(e,s,t)$ for every $e\in\Eout(v)$.
    \item Receive $P^+(e,s,t)$ for every $e\in\Ein(v)$, and $R(e,s)$ for every $e\in \Eout(v)$.
    \item \label{line:Rin}
$R_{in} \gets \min\{\sum_{e\in\Eout(v)} R(e,s),$\\
$ \sum_{e\in\Eout(v)} P^+(e,s,t), \sum_{e\in\Ein(v)} P^+(e,s,t),
            \}$.
          \item \label{line:Res}
For every $e\in\Ein(v)$: $R(e,s) \gets R_{in} \cdot
            \frac{P^+(e,s,t)}{\sum_{e'\in\Ein(v) P^+(e',s,t)}}$.
            \item Drop oldest packets from $Q(v,s)$, if needed, so
              that $|Q(v,s)|\leq R_{in}$.
    \end{enumerate}
  \end{enumerate}
\end{algorithm}

\section{Experimental Results}
\subsection{General Setting}

Tools. CLP, C++, OMNET++/MixiM

Radio. Wifi 802.11g, radiuses., $\alpha=4.1$, fixed transmission power.
$N=-100dBm$.
max comm distance
typical interference dist


Video Streams. Packet size.
64 packets per second if stream rate is 1mbps.

Algorithm parameters:
\#slots
slot length
period
number of freq

simplification in the implementation:
flow control messages are not implemented.

simple implementation:
algorithm only packs one stream per link in each table entry.
(only reduces the performance of the algorithm)

Clean air threshold:
with schedule:
without schedule: 500m

\subsection{Scenarios}
We ran the experiments on two main types of arrangements of the nodes
in the plane: a circle and a grid.

\begin{enumerate}
\item In the grid arrangement, we positioned $49$ nodes in a
  $1km\times 1km$ square. The nodes are positioned in a $7\times 7$
  lattice, so that the horizontal and vertical distance between
  adjacent nodes is $1000/7=142$ meters (see Fig.~\ref{fig:scenario
    grid}).    The source and destination of the streams
  in the grid arrangement are chosen randomly.

\item In the circle arrangement, we positioned $24$ nodes on a circle
  of radius $500$ meters.  The nodes were positioned every $360/24$
  degrees (see Fig.~\ref{fig:scenario circle}). The source and
  destination of the streams in the circle arrangement are chosen
  deterministically, by $a_i=\lceil 24/k \rceil$, $b_i=(a_i + \lfloor
  24/k \rfloor) \bmod 24$, where $k$ denotes the number of streams.
\end{enumerate}

We point out that random locations of $50$ nodes in a square kilometer
induces a communication graph with a high degree and a diameter of
$2-3$~\cite{marina2010topology}. In addition, the interference set of
each link contains almost the other links. Hence, this setting has a
low capacity and is not an interesting setting for the problem we
study.

The requests demand $d^*_i$ is set to $50$mbs. Such a demand with
$k\geq 6$ streams is above the capacity of the network. This enables
us to study the performance in a congested setting.

\subsection{Benchmarks}
We ran the experiments using five algorithms:
\begin{enumerate}
\item \algS - a shortest path maximum bottleneck routing algorithm.
  Let $\pps(e)$ denote the number of packets-per-slot in the
  \MCS\ used by the link $e$.  Let $\hops(p)$ denote the number of
  hops along a path $p$. In \algS, the stream $s$ is routed along a
  path $p$ from $a_s$ to $b_s$ such that, for every path $p'$ from
  $a_s$ to $b_s$, the following holds:
  \begin{align*}
    \min_{e \in p} \pps(e) &\geq \min_{e \in p'} \pps(e) \text{ , and}\\
    \min_{e \in p} \pps(e) &= \min_{e \in p'} \pps(e)  \\
\Longrightarrow &\hops(p) \leq \hops(p').
  \end{align*}
  The paths assigned to the $k$ streams are divided evenly among the
  three frequency channels.

Each node in this benchmark contains three
  radios. This means that each node contains three standard 802.11g
  WNICs, each working in different frequency channel.  Since the
  frequency channels are non-overlapping, one WNIC may receive while
  another WNIC is transmitting.  Each WNIC receives and transmits
  packets according to the WiFi MAC.  Fairness between the streams is
  obtained as follows.  Each WNIC is given FIFO-queue for each stream,
  the packets of which it needs to transmit. Each WNIC uses a simple
  round-robin policy for determining the queue from which the next
  packet is transmitted.

  The paths are computed in an oblivious manner, namely, congestion
  does not play a role. This means that we must execute a flow control
  algorithm to adjust the data-rate.  To execute the Flow-Control
  algorithm without any changes, we trivially cast this routing to our
  setting as follows.  We define the multi-flow $\mf(e,s)$ to equal
  $d^*_s$ if $e$ is in the path assigned to stream $s$, and $0$
  otherwise. The time-slotted frequency table $A$ has a single time
  slot (i.e., $T=1$) whose duration is one second. Namely, the table
  $A$ has three entries, one for each frequency channel.  The table
  entry for frequency channel $j$ lists the links that use frequency
  channel $j$.
\item \algA. In the \algA\ benchmark all three parts of our algorithm
  are used: computation of a multicommodity flow with interference
  constraints, the path-peeling scheduler, and the Flow-Control
  algorithm,

  We emphasize that in this benchmark, each node contains a single
  radio; namely, each node has a single standard 802.11g WNIC capable
  of hopping between the three frequency channels in the beginning of
  each time slot.

\item \algE\ - same as \algA\ except that the LP does not include
  interference constraints. The scheduler resolves interferences, so
  it is interesting to see how much throughput is scheduled by the
  scheduler, and whether this throughput is routed in the simulation.

  We point out that the interference constraints constitute a large
  part of the LP constraints. By omitting them, the LP becomes
  shorter, easier to solves, and naturally, the LP solution has a
  higher throughput.


  Since the LP lacks interference constraints, the scheduler may fail
  to schedule the flow. We modified the scheduler in this case so that
  it augments the table $A$ by adding time-slots. This augmentation
  has an adverse effect of reducing throughput and increasing delay.


\item \algC\ - same as \algA\ but without the scheduler.  Instead, the
  multi-flows are assigned in a single-slot schedule, as in Algorithm
  \algS. We point out that in this benchmark, each node is equipped
  with three WNICs as in Algorithm \algS.

  The motivation for this benchmark is that the multi-flow takes into
  account congestion and interference. Since the WiFi MAC deals with
  avoiding collisions, so it is interesting to see how it succeeds in
  scheduling the multi-flows in a distributed manner.

As in \algS, each node has three WNICS in this benchmark.

\item \algD\ - similar \algS\ except that the the streams are routed
  according to a multi-commodity flow. The multi-commodity flow is
  computed by an LP without interference constraints.  This benchmark
  helps understand whether non-oblivious congestion aware routing
  improves performance.

As in \algS, each node has three WNICS in this benchmark.
\end{enumerate}

\subsection{Results}

\paragraph{Grid scenario - \algA}
The input to the \algA\ algorithm is as follows.
The arrangement is the grid arrangement.
There are $49$ nodes positioned in in the arrangement.
The node that is positioned in the $i$th row and $j$th column is denoted by the index $i+7(j-1)$.
Every stream request is routed along paths in the grid.
We elaborate on the scenario where $k=12$.
%A path is a sequence of nodes.
The stream requests are as follows:
\begin{inparaenum}[(i)]
\item $r_1 = (24,13,50)$,
\item $r_2 = (7,38,50)$,
\item $r_3 = (49,13,50)$,
\item $r_4 = (6,27,50)$,
\item $r_5 = (31,5,50)$,
\item $r_6 = (30,16,50)$,
\item $r_7 = (2,10,50)$,
\item $r_8 = (4,31,50)$,
\item $r_9 = (22,17,50)$,
\item $r_{10} = (23,4,50)$,
\item $r_{11} = (28,29,50)$,
\item $r_{12} = (2,1,50)$,
\end{inparaenum}

The output of \algS\ is depicted in Figure~\ref{fig:scenario grid}.
Note that a request may be routed along multiple paths.

%The paths of each stream are as follows.
%\begin{enumerate}
%    \item $24 \rightarrow 17 \rightarrow 10 \rightarrow 11 \rightarrow 12 \rightarrow 13$, $24 \rightarrow 25 \rightarrow 18 \rightarrow 19 \rightarrow 20 \rightarrow 13$, $25 \rightarrow 26 \rightarrow 27 \rightarrow 20 \rightarrow 13$.
%    \item $ 7 \rightarrow 14 \rightarrow 21 \rightarrow 28 \rightarrow 35 \rightarrow 42$.
%    \item $37 \rightarrow 38 \rightarrow
%\end{enumerate}



\paragraph{Circle scenario - \algA}
The input to the \algA\ algorithm is as follows.
The number of requests is $k=12$.
The arrangement is the circle arrangement.
There are $24$ nodes in the circle arrangement.
The node that is positioned in $3$o'clock is denoted by `$1$'.
The node numbering is clockwise with respect to node number one.
Every stream request is routed along paths in the circle.
%A path is a sequence of nodes.
The stream requests are $\{r_i=(2i,2i+2,50)\}_{i=1}^{11},r_{12}=(1,3,50)$.

The output of \algS\ is depicted in Figure~\ref{fig:scenario circle}.
Note that a request may be routed along multiple paths.


\paragraph{Effect of number of streams}
Table~\ref{tab:minthroughput} depicts the minimum throughputs of \algA\ and \algS\ in the grid scenario.
The number of requests $k$ is $8,12,16$. The demand for every stream request is $50$ Mbps.

It can be seen from the table that minimum throughput decreases as the number of requests increases, both in \algA\ and \algS.
Moreover, \algA\ algorithm achieves at least $20-40$ percent more throughput than the \algS\ algorithm.

\begin{table}
\centering\small
\begin{tabular}{|| l || c | c | c ||}

\hline
k & \algA 's min Throughput & \algS 's min Throughput & Ratio\\
\hline
& Mbps & Mbps & \\
\hline\hline
8 & 0.448 & 0.368  & 1.217  \\
12 & 0.336 & 0.24 & 1.4 \\
16 & 0.144  & 0.112 & 1.285 \\
\hline
\end{tabular}
\caption{The leftmost column lists the number of requests $k$ in the grid scenario. The second row lists the minimum throughout for $ k \in \{8,12,16\}$ in the \algA algorithm. The demand for each stream request is $50$ Mbps. The third row lists the minimum throughout for $ k \in \{8,12,16\}$ in the \algS. Every entry in the rightmost row corresponds to the ratio between the minimum throughput of \algA\ and \algS.}
\label{tab:minthroughput}
\end{table}

\paragraph{Effect of single radio on \algS}
Figure~\ref{fig:radio13} depicts the Effect of single radio on \algS. 
The experiment was made in the grid arrangement, where The number of requests is $k=12$.
The demand for every stream request is $50$ Mbps.

It can be seen from the figure that the total throughout in the \algS algorithm with $3$ radios is, roughly, three times higher than the \algS algorithm with a single radio.

Note that in the following comparisons the \algS\ is applied with $3$ radios in every node, opposing \algA\ which has a single radio in every node.

\begin{figure}[h!]
      \centering
        \subfloat{\label{fig:small1}\includegraphics[width=0.5\textwidth]{3radio_vs_1radio.eps}}\\
        \caption{The y-axis is the total throughput, that is the sum over all the throughputs of every stream request.  The x-axis is time. The dashed line depicts the total throughput of \algS\ with three radios. The full line depicts the total throughput of \algS\ with a single radio. The arrangement is the grid arrangement. The number of requests is $k=12$. }
      \label{fig:radio13}
     \end{figure}

\paragraph{Fairness}
Figure~\ref{fig:fair} compares the throughputs achieved for each stream in \algA\ and \algS algorithms.
The experiment was made in the grid arrangement, where The number of requests is $k=16$.
The demand for every stream request is $50$ Mbps.

It can be seen that \algA\ every stream achieves, roughly, the same throughput.
The leftmost stream $s$ was routed along a single link $e$, and it hardly interferes with the other stream requests.
Moreover, the experiments showed that \MCS(e)=2, and $c(e)=7.4$. 
Hence, the throughput achieved by $s$ is decresed by $30$ percent.

On the other side, the throughputs achieved by \algS\ are not spread evenly among the streams.
Furthermore, it can be seen that \algA\ gains a higher throughput in  $7$ out of the requests.

\begin{figure}[h!]
      \centering
        \subfloat[]{\label{fig:small3}\includegraphics[width=0.5\textwidth]{fairness_compare.eps}}\\
        \caption{The y-axis is throughput. Streams are sorted by their throughput, where the highest throughput is positioned on the left of the x-axis. time. The black bars are correspond to a throughput gained by the \algA\ algorithm. The white bars correspond to a throughput gained by the \algS\ algorithm. The arrangement is the grid arrangement. The number of requests is $k=12$. }
      \label{fig:fair}
     \end{figure}

\paragraph{The Flow-Control algorithm}

Figure~\ref{fig:fcbig} depicts the effects of the flow-control algorithm applied in \algA\ algorithm.
The experiment was made in the grid arrangement, where The number of requests is $k=12$.
The demand for every stream request is $50$ Mbps.



It can be seen that \algA\ every stream achieves, roughly, the same throughput.
The leftmost stream $s$ was routed along a single link $e$, and it hardly interferes with the other stream requests.
Moreover, the experiments showed that \MCS(e)=2, and $c(e)=7.4$.
Hence, the throughput achieved by $s$ is decresed by $30$ percent.

On the other side, the throughputs achieved by \algS\ are not spread evenly among the streams.
Furthermore, it can be seen that \algA\ gains a higher throughput in  $7$ out of the requests.

queue lengths

dropped packets

perturbations in the requested packet-rate per link

\textbf{suggest other ways to implement the flow-control messages (incorporate
in ACKs, send in the beginning of a time slot, reserve control slots).}


\begin{figure}[h!]
      \centering
        \subfloat[]{\label{fig:fcsmall1}\includegraphics[width=0.5\textwidth]{fc_rate_long_grid_12r_new.eps}}\\
        \subfloat[]{\label{fig:fcsmall2}\includegraphics[width=0.5\textwidth]{q_len_max_multi_1_fig.eps}}\\
        \subfloat[]{\label{fig:fcsmall3}\includegraphics[width=0.5\textwidth]{max_drop_in_time_grid_12r.eps}}\\
        \subfloat[]{\label{fig:fcsmall4}\includegraphics[width=0.5\textwidth]{tp_stability.eps}}\\
        \caption{The following $4$ figures show the effect of the flow-control algorithm applied in \algA. In Figure~\ref{fig:fcsmall1}: The y-axis is $R(e,s)$, that is the requested packet rate by the flow-control algorithm.  The x-axis is time. The two lines depict $R(e,s)$, for two different links in two different streams. 
        In Figure~\ref{fig:fcsmall2}: The y-axis is number of packets. The x-axis is time. A line depicts the changing number of packets in a queue. Three different queues are presented, one for each node.
        In Figure~\ref{fig:fcsmall3}: The y-axis is the ratio between the number of droppednumber of packets. The x-axis is time. A line depicts the changing number of packets in a queue. Three different queues are presented, one for each node.
        
        
        The arrangement is the grid arrangement. The number of requests is $k=12$.
        }
    \label{fig:fcbig}
     \end{figure}


\paragraph{Comparison with greedy scheduler}


\begin{figure}[h!]
      \centering
        \subfloat[]{\label{fig:small11}\includegraphics[width=0.5\textwidth]{tp_sched_comparison.eps}}\\      \subfloat[]{\label{fig:small5}\includegraphics[width=0.5\textwidth]{max_delay_greedy_vs_smart.eps}}\\
        \subfloat[]{\label{fig:small9}\includegraphics[width=0.5\textwidth]{throughput_greedy_sched_grid_12r.eps}}\\
        \subfloat[]{\label{fig:small10}\includegraphics[width=0.5\textwidth]{throughput_smart_sched_grid_12r.eps}}\\ \label{fig:big3}
     \end{figure}
\paragraph{Stability}
of throughput

of delay


\input{tables12.tex}


%%%%%% Scenarios and benchmarks
\begin{figure}%[h!]
      \centering
        \subfloat{\label{fig:small18}\includegraphics[width=0.4\textwidth, height = 0.4\textheight]{scenario_main_grid_12r.eps}}
       \caption{....}
      \label{fig:big6}\label{fig:scenario grid}
     \end{figure}

\begin{figure}%[h!]
      \centering
        \subfloat{\label{fig:small13}\includegraphics[width=0.5\textwidth, height = 0.5\textheight]{scenario_main_circle_12d.eps}}
        \caption{....}
      \label{fig:big5}\label{fig:scenario circle}
     \end{figure}


\section{Conclusions}
stable and predictable results that compete well with nodes equipped with $3$ radios.



\section{Discussion}
central algorithm - relies on an established network.
algorithm may be computed in multiple nodes (deterministic, will outcome the same results)
distribution of tables via broadcast is easy (small tables)

flow control needs to sense clean air.

Formulated a new problem: scheduling of multi-flows to reduce
end-to-end delay.

future:
mobile users - how fast does performance degrade?
Consider continuous re-computations of tables with expiration times.

consider approximate distributed multi-commodity flow algorithms


%
\ifnum\conff=0
  \subsection*{Acknowledgments}
  We thank Nissim Halabi for useful discussions.
\fi
%

%\nocite{*}
\bibliographystyle{alpha}
\bibliography{wireless}

\newpage
\appendix
\end{document}
